// Template synthdefs
SynthDef.new(\l1fx_lala,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673;
	var input, fx, env, verb, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	fx = CheapVerb.ar(input, 0.4,20);

	Out.ar(out, ((dry*input) + (fx*amp))*env);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_lala,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243;
	var src, env, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	src = SinOsc.ar(freq, mul:1);

	OffsetOut.ar(out, (src*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


// utility functions
~postArgs = {
	arg synthName;
	var path, f, descSynth;
	path = ('~/' ++ '_presetPaste').standardizePath;
	f = File(path,"w");

	descSynth = SynthDescLib.at(synthName).controls.collect{arg item; ["\n" ++ "\\"++ item.name.asSymbol, item.defaultValue.round(0.0000001)]}.flatten.asString.replace("[").replace("]");

	f.write(descSynth);
	f.close;

	("pbcopy < "++path).asString.unixCmd;
};

~postArgsPbind = {
	arg synthName;
	var path, f, descSynth, isFx;
	path = ('~/' ++ '_presetPaste').standardizePath;
	f = File(path,"w");

	descSynth = SynthDescLib.at(synthName).controls;
	isFx = synthName.asString.contains("fx_");


	descSynth = descSynth.select{arg item; (item.name.asSymbol != 'gate') && (item.name.asSymbol != 'out')&& (item.name.asSymbol != 'in')&&(item.name.asSymbol != 'freq') };

	descSynth  = descSynth.collect{
		arg item;
		item.name.asString.postln;
		isFx.if{
			["\n" ++ "\\fx_"++ item.name.asString, item.defaultValue.round(0.0000001)];
		}
		{
			["\n" ++ "\\"++ item.name.asString, item.defaultValue.round(0.0000001)];
		};
	};
	descSynth = descSynth.flatten.asString.replace("[").replace("]");

	isFx.not.if{
		descSynth = descSynth.insert(0,"\\instrument, '" ++ synthName.asString ++ "',\n\\dur, 1,\n\\octave, 4,\n\\degree, 0,\n\\legato, 1,\n//////synth parameters");

	}
	{
		descSynth = descSynth.insert(0,"\\type, \\noteFx,\n\\monoFX, false,\n\\fx,  '" ++ synthName.asString ++ "',\n\\fx_legato, 1,\n//////fx parameters");
	};
	f.write(descSynth);
	f.close;
	descSynth.postln;

	("pbcopy < "++path).asString.unixCmd;
};

~postArgsEvent = {
	arg synthName;
	var path, f, descSynth;
	path = ('~/' ++ '_presetPaste').standardizePath;
	f = File(path,"w");

	// a = a
	descSynth = SynthDescLib.at(synthName).controls;
	descSynth = descSynth.select{arg item; (item.name.asSymbol != 'gate') && (item.name.asSymbol != 'out') };
	descSynth = descSynth.collect{arg item; [item.name.asString.asSymbol, item.defaultValue.round(0.0000001)]}.flatten.as(Event);//.removeItems("t_")
	descSynth[\dur] = 1;
	descSynth = descSynth.asString();

	descSynth = descSynth.removeItems("\n");
	descSynth = descSynth ++ ".play;";
	descSynth = descSynth.insert(1," \'instrument': '" ++ synthName.asString ++ "',");
	f.write(descSynth);
	f.close;
	("pbcopy < "++path).asString.unixCmd;

};

~randomMetadataPlay = {
	arg synthname, freq= 100, dur=0.3;
	var metadata, evt;
	metadata = SynthDescLib.global[synthname].metadata[\specs].copy;
	// metadata.postln;
	metadata = metadata.keysValuesChange{arg key, value; key.postln; value.map(rrand(0,1.0))};
	evt = (instrument: synthname, freq:freq, dur:dur, amp: 1);
	evt = evt.merge(metadata);
	evt.play;
};


// Synthdefs
//split into files?
SynthDef.new(\l1_fxDown,{
	arg freq, amp = 1, len = 5, curve = -4, dirt = 1, out = 0, gate = 1;
	var src, env, envPitch, envMod, dirtSig;
	// env = Env.adsr(0, len ,0,0.05,curve:5);
	env = Env.linen(0,0,len,1,5);
	env = EnvGen.ar(env, 1, doneAction:2);
	envPitch = Env.adsr(0, len*0.5,0,0.05);
	envPitch = EnvGen.ar(envPitch, 1);

	envMod = Env.adsr(len, 0.03,0,0.05,curve: curve);
	envMod = EnvGen.ar(envMod, 1);

	src = SinOsc.ar(freq + envPitch.linlin(0,1,0,freq*3), mul:amp*env);
	src = src + AllpassL.ar(src, 0.2, 0.1*envMod,len*2);

	src = LeakDC.ar(src);

	dirtSig = (src.softclip*10).tanh;

	dirtSig = HPF.ar(dirtSig, freq * 2);
	dirtSig = HPF.ar(dirtSig, freq * 2);
	dirtSig = HPF.ar(dirtSig, freq * 3);
	dirtSig = dirtSig * dirt;

	src = src + dirtSig;
	OffsetOut.ar(out, (src*env)!2);
},
metadata:(specs:(len:ControlSpec.new(0.1, 20), curve:ControlSpec.new(-10,4),dirt:ControlSpec.new(0,1), ))).add;
// )
// Synth.new(\l1_fxDown, [freq:43, len:4, dirt:1, curve:-4])

// Synth.new(\l1_fxDown, [freq:43, len:4, dirt:0, amp:1, curve:-1])

// SynthDescLib.global[\l1_fxDown].metadata[\specs]

// transient
// (
SynthDef.new(\l1_transient,{
	arg freq, amp = 1, smear = 0.2, smearSpeed = 1, transient = 3, len = 0.06, out = 0, gate = 1;
	var src, env, envPitch, envMod;
	// env = Env.adsr(0, len ,0,0.05,curve:0);
	env = Env.perc(0,len,curve:1);
	env = EnvGen.ar(env, doneAction:2);
	envPitch = Env.adsr(0, len*0.5,0,0.05);
	envPitch = EnvGen.ar(envPitch, 1);

	envMod = Env.adsr(len, 0.03,0,0.05);
	envMod = EnvGen.ar(envMod, 1);

	src = SinOsc.ar(freq + envPitch.linlin(0,1,0,freq*transient), mul:amp*env);
	src = src + AllpassL.ar(src, 0.2, LFSaw.ar(smearSpeed*len.reciprocal, pi).range(smear.linexp(0,1,0.002,0.2),0.001),0.1);

	OffsetOut.ar(out, (src*env*amp)!2);
},
metadata:(specs:(smear: ControlSpec(0,1), smearSpeed: ControlSpec(0.001,200,\exp), transient: ControlSpec(0,80,4), len: ControlSpec(0.001, 0.5,2))) ).add;
// )
// 0.06.reciprocal

// Synth.new(\l1_transient, [freq:20, len:0.3, dur:0.2, smear:0.5, amp:0.4, smearSpeed:0.2, transient:10])
// SynthDescLib.global[\l1_transient].metadata[\specs]

// (
// Pdef(\patt, Pbind(\instrument, \l1_transient, \freq, [1000, 200], \amp, 0.5, \len,[0.01, 0.02], \timingOffset, [-0.01,0], \transient, 10, \dur, 0.75, \smear, 1, \smearSpeed, Pwhite(0.2,3!2)));
// );
//
// Pdef(\patt2, Pbind(\instrument, \l1_transient, \freq, [2000, 500], \amp, Pseq([Rest(), 0.5],inf), \len,[0.01, 0.02]*0.5, \timingOffset, [-0.014,0], \transient, 10, \dur, 0.25, \smear, [0.1,1], \smearSpeed, Pwhite(0.2,3!2)));
// )
// )
// Pdef(\patt).play
// Pdef(\patt2).play

// --------- noisy chord
// (
SynthDef.new(\l1_noiseChord,{
	arg freq, amp = 1,ratio=1, decay = 2, out = 0, gate = 1, vibrato = 0.1, modAttack = 0.6;
	var src, env, envMod, f1, f2, bus;
	env = Env.adsr(0.05, decay,0.8,0.05);
	env = EnvGen.ar(env, gate, doneAction:2);

	envMod = Env.adsr(modAttack, 0.4,0,0.05);
	envMod = EnvGen.ar(envMod, gate);

	src = PMOsc.ar(freq,(freq*ratio) + SinOsc.ar(5,mul:freq*vibrato.linlin(0,1,0,0.1)),envMod.linlin(0,1,0.1,0.6),WhiteNoise.ar(0.2), mul:env);

	f1 = LPF.ar(src, freq * 2);
	f1 = f1 + HPF.ar((f1*10).tanh,(freq*16).clip(0,15000));

	f2 = HPF.ar(src, freq * 4, mul:4);
	// f2 = BPF.ar(f2, freq * 4 * LFPulse.ar(10).range(0.1,1), 4).excess(-30.dbamp);
	// f2 = HPF.ar(AllpassL.ar(f2, 0.2,(0.04 * f2).clip(0.005,0.1),0.02).softclip,freq*3, mul:-12.dbamp);
	f2 = AllpassL.ar(f2, 0.2,([0.01,0.02] * f2).clip([0.05,0.01],0.1),0.004).softclip;
	f2  = Splay.ar(f2, 0.8);

	bus = amp*((f2+(f1!2))).clip(-1,1);
	OffsetOut.ar(out, bus);
},
metadata:(specs:(ratio:ControlSpec(0.125,8), decay:ControlSpec(0,2), vibrato:ControlSpec(0,1), modAttack:ControlSpec(0,20)))
).add;
// )

// (\instrument: \l1_noiseChord,\freq: [100,200], \dur: 10, \vibrato:0.1, \ratio:0.5, \amp:0.5, \decay:0.8, \modAttack:10).play
// (\instrument: \l1_noiseChord,\freq: [100,200, 300, 400, 500], \dur: 1, \vibrato:1, \ratio:1, \amp:0.5).play
// (\instrument: \l1_noiseChord,\freq: ([0,4,7,11] + 48).midicps, \dur: 1, \vibrato:1, \ratio:1, \amp:0.5).play
// (\instrument: \l1_noiseChord,\freq: [80], \dur: 1, \vibrato:[0,1], \ratio:1, \amp:0.5).play
// SynthDescLib.global[\l1_noiseChord].metadata[\specs]
//
//
// (\instrument: \l1_noiseChord,\freq: [80, 160], \dur: 4, \vibrato:[0,1], \ratio:0.49, \amp:0.3).play

// Synth.new()
// (
// Pdef(\l1_noiseChord).quant = 4;
// ~middleNote = 3;
// Pdef(\l1_noiseChord, Pbind(\instrument, \l1_noiseChord,
// 	\base, Pn(Pseries(0,1,4)),
// 	\root, 0,
// 	\degree, (Pkey(\base) + Pfunc{[0,~middleNote,8]}).wrap(0,9),
// 	\octave, [3,5,5]-1,
// 	\legato, 0.75,
// 	\amp, Pwhite(0.37!3,0.5)*0.14,
// 	\dur, 2,
// 	// \vibrato, 0.2,
// 	\modAttack, Pn(Pseries(0,1,4)) * 0.6,
// ));
//
// // Pdef(\l1_noiseChord).play;
// )

// ~middleNote = 2;

// TempoClock.default.tempo = 120/60

// soft start swelling chord

// pad complex


// ---------- hat

// (


SynthDef(\l1_hatWN, {
	arg amp = 1, attack = 0, hold = 0.2, release = 0.1, hpf = 2000, out = 0, seed = 5673;
	var src, env;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);
	env = Env.pairs([[0,0.00001], [attack,1], [attack+0.01,0.25], [attack+0.01+hold, 0.25], [attack+0.01+hold+release,0.0001]], [0,0,0,-2]);
	env = EnvGen.ar(env, 1, doneAction:2);
	src = WhiteNoise.ar(env*amp);
	src = HPF.ar(src, hpf);

	OffsetOut.ar(out, src!2);

},
metadata:(specs:(attack:ControlSpec(0,0.5), hold:ControlSpec(0,4), release:ControlSpec(0,4), hpf:ControlSpec(100,10000, \exp)))
).add;

// )

// Synth.new(\l1_hatWN, [seed:1000, hpf:200]);
// Synth.new(\l1_hatWN, [seed:1000, hpf:100, attack: 0, hold:0.05, release:0]);

// SynthDescLib.global[\l1_hatWN].metadata[\specs]


// ----------- hat 2

// (


SynthDef(\l1_hatWN2, {
	arg amp = 1, transient = 1, attack = 0, plateau = 0.25, hold = 0.2, release = 0.1, hpf = 2000,brf = 5000,brf2 = 8000, out = 0, seed = 5673;
	var src, env, envFade, noise;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);
	env = Env.pairs([[0,0.00001], [attack,1], [attack+0.01,plateau], [attack+0.01+hold, plateau], [attack+0.01+hold+release,0.0001]], [0,0,0,-2]);
	env = EnvGen.ar(env, 1, doneAction:2);

	envFade = Env.perc(attack,0.01,1,0);

	envFade = EnvGen.ar(envFade, 1);
	noise = WhiteNoise.ar(env*amp);
	src = HPF.ar(noise, hpf);
	src = BRF.ar(src, brf,2);
	src = BRF.ar(src, brf2,2);

	src = SelectX.ar( envFade*transient, [src, noise]);

	OffsetOut.ar(out, src!2);

},
metadata:(specs:(transient:ControlSpec(0,1) ,attack: ControlSpec(0,0.5),plateau: ControlSpec(0,1),hold: ControlSpec(0,4),release:ControlSpec(0,4) ,hpf: ControlSpec(100,10000, \exp),brf: ControlSpec(200,10000, \exp),brf2: ControlSpec(200,10000, \exp),seed: ControlSpec(0,6000)))
).add;

// )

// Synth.new(\l1_hatWN2, [seed:1000, hpf:200]);
// Synth.new(\l1_hatWN2, [seed:1000, hpf:200, attack: 0, hold:0.6, release:0.1, plateau:0.5]);

// Pdef(\l1_hat2).quant = 4;
// Pdef(\l1_hat2, Pbind(\instrument, \l1_hatWN2, \amp, 1, \hpf, 200, \brf, 6000, \brf2, 2000, \amp,0.5, \hold, 0.02, \dur, 1));
// Pdef(\l1_hat2).play;


//get list of synth args


// sub lfo

// neuro stab lowpass and multi dist

//kick

//softkick

// warm saw filtered stab

// trap clump

// ambiance

// bass swelling

// (
// {
SynthDef.new(\l1_bassSwell,{
	arg freq, attack =0, amp = 1, pump = 1, moreTone = 1, pumpTime = 0.4, div = 1, fmIndex = 1, fmBeat = 0.1,modFilter = 20, decay1 = 0.2,decay2 = 1, out = 0, gate = 1, quitAfter, replyID = -1;
	var src, env, fEnv, pls, modOsc, plsFEnv, low, high, highEnv;
	env = Env.adsr(attack, 0.3,1,0.05);
	env = EnvGen.ar(env, gate, doneAction:0);


	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	SendReply.kr(Impulse.kr(60), "/l1_bassSwell/env", env, replyID);



	fEnv = Env.adsr(attack, decay1,0,0.05);
	fEnv = EnvGen.ar(fEnv, gate);

	plsFEnv = Env.adsr(attack, decay2,0,0.05,curve:-1);
	plsFEnv = EnvGen.ar(plsFEnv, gate);

	highEnv = Env.adsr(pumpTime, 0,1,0.05, curve:2);
	highEnv = EnvGen.ar(highEnv, gate);

	SendReply.kr(Impulse.kr(60), "/l1_bassSwell/fEnv", fEnv, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_bassSwell/plsFEnv", plsFEnv, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_bassSwell/highEnv", highEnv, replyID);


	modOsc = SawDPW.ar((-1*freq)+fmBeat, mul:env);
	src = SawDPW.ar(freq + (freq*modOsc*fmIndex), mul:env);
	pls = PulseDivider.ar(src,div);
	pls = BRF.ar(pls, plsFEnv.linexp(0,1, 400,2000),4);

	pls = Sanitize.ar(pls);
	src = DFM1.ar(src, (freq*2* fEnv.linlin(0,1,1,modFilter)) + (src*freq*1) , 0.9,1.1) + (pls * -12.dbamp);//+ (src*freq)//* fEnv.linlin(0,1,1,4)

	// low = BRF.ar(src, 4000, 4);
	// high = BPF.ar(src, 4000, 4);

	low = LPF.ar(src, freq*2);
	high = HPF.ar(src, freq*2);

	high = high + LPF.ar(WaveLoss.ar(high,1,4), freq*4);
	high = (high*highEnv).tanh.distort;


	// src = high;
	// src = low;
	src = SelectX.ar(pump, [src, low + high]);

	// src = ;
	src =SelectX.ar(moreTone, [src, src + BPF.ar(WaveLoss.ar(src,2,4), plsFEnv.linexp(0,1, 400,2000),rq:0.5, mul:1.5)]);

	src = amp*src;
	OffsetOut.ar(out, src!2);
},
metadata:(specs:( attack: ControlSpec(0,2,\exp), pump: ControlSpec(0,1), moreTone:ControlSpec(0,1), pumpTime:ControlSpec(0,2), div:ControlSpec(1,8,step:1), fmIndex:ControlSpec(0,100, 20), fmBeat:ControlSpec(0,7, 4), modFilter:ControlSpec(0,90), decay1:ControlSpec(0,10,4), decay2:ControlSpec(0,10,4)), oscReplies:["/l1_bassSwell/fEnv","/l1_bassSwell/plsFEnv","/l1_bassSwell/highEnv", "/l1_bassSwell/env"])).add;
// s.sync;
/*(instrument: \l1_bassSwell, dur: 1, freq:48.midicps, amp:1).play;*/
// }.fork;
// )


// SynthDescLib.global[\l1_bassSwell].metadata[\specs]

// (instrument: \l1_bassSwell, dur: 1, freq:36.midicps, amp:1, attack:0, pump:1, pumpTime:2, fmIndex:0, fmBeat:0, modFilter:90, decay1:0.2, decay2:0.1).play;
// ~randomMetadataPlay.value(\l1_bassSwell, 100, 2)

// (

// {
SynthDef(\l1_ambiance,{
	arg freq, amp = 1, out = 0, gate = 1;
	var src, env;

	// RandID.ir(id: 0);
	// RandSeed.kr(trig: Impulse.kr(100), seed:29993 + LFSaw.ar(0.5, mul:10));//noise osc
	// RandSeed.kr(trig: Impulse.kr(100), seed:29993 + LFSaw.ar(0.5, mul:10));//noise osc
	env = Env.adsr(0.01, 0.3,1,0.05);
	env = EnvGen.ar(env, 1, doneAction:2);

	src = BrownNoise.ar((amp!2)*env);
	src = LowShelf.ar(src, 300, 0.3,-4);
	src = Splay.ar(src,0.9);
	src = MidEQ.ar(src, LFNoise2.ar(0.1).range(300, 600),2,-10);
	src = MidEQ.ar(src, LFNoise2.ar(0.1).range(2000, 4000!2),2,-3);

	src = Splay.ar(src,0.9);
	// src = src + BPF.ar(src, 10.collect{Rand(300,5000)}.stutter(2), 0.1, 12.dbamp);
	src = src + BPF.ar(src, LFNoise1.ar(0.01).range(200!4, 1000).stutter(2), 0.05, 12.dbamp);
	src = BRF.ar(src, LFNoise1.ar(0.01).range(1000, 5000), 0.2);
	src = Splay.ar(src);

	Out.ar(out, src);
},
metadata:(specs: ( ) )
).add;

// s.sync;

/*Synth.new(\l1_ambiance, [amp:0.1])*/
// }.fork;
// )

// (
SynthDef.new(\l1_kick,{
	arg freq, attack = 0, amp = 1, out = 0, gate = 1, chirp = 0, envAmount = 20, timeScale = 1;
	var src, env, pitchEnv, attackenv;
	env = Env.adsr(attack, 0.15,-4.dbamp,0.1, curve:0);
	env = EnvGen.ar(env, gate, doneAction:2);

	pitchEnv = Env.xyc([[0,1,-8], [0.01,chirp.linlin(0,1,0.1,0.25),-1], [0.03, 0.05,0], [0.05,0,0]]);
	pitchEnv = EnvGen.ar(pitchEnv, gate, timeScale: timeScale);

	src = SinOsc.ar(freq * pitchEnv.linlin(0,1,1,envAmount), mul:amp*env);

	OffsetOut.ar(out, src!2);
},
metadata:(specs: ( attack:ControlSpec(0,1, 2), chirp:ControlSpec(0,1), envAmount: ControlSpec(0,200, 2), timeScale:ControlSpec(0.1,10, 2)) )
).add;
// s.sync;
// (instrument: \l1_kick, dur: 0.2, freq:36.midicps).play;
// }.fork;

// )



// (instrument: \l1_kick, dur: 0.2, freq:24.midicps, amp:1, chirp:0, timeScale:0.1, envAmount:300, attack:0).play;
// ~randomMetadataPlay.value(\l1_kick, 40, 0.2)

// 24.midicps.reciprocal
// {SinOsc.ar(40)}.plot(0.02)
// Env.xyc([[0,1,-7], [0.01,0.2,0], [0.03, 0.07,-1], [0.1,0,0]]).plot


// patterns:
//get all arguments in pattern format and copy to paste buffer
//set the range of arguments for smart stuff
// [instrument: \l1_kick, dur: 0.05, freq:24.midicps, amp:1, chirp:0.6, timeScale:1, envAmount:100, attack:0.04]

// (
// Pdef(\kickTest,
// 	Pbind(\instrument, \l1_kick,
// 		\dur, 0.01,
// 		\legato, 0.8,
// 		\freq,24.midicps,
// 		\amp,1,
// 		\chirp, 0,
// 		\timeScale, 0.7,
// 		\envAmount, 60,
// 		\attack, 0,
// 		// \fx, \l1_bandPass
// 	).collect{|evt|
// 		evt.postln;
// 		evt.play;
// 		evt[\amp] = Rest();
// 		// evt[]
// 	evt; }
//
// );
// )
// Pdef(\kickTest).play

//-------- SAW

// (
SynthDef(\l1_supersaw7, {
	arg freq = 1000, detune = 0.3, release = 0.2, mix = 0.4, amp = 1, out = 0, gate = 1, attack = 0, modPhase = 0, pitchbend = 0, replyID = -1;
	var src, env, paned, quitAfter;
	freq = (pitchbend.midiratio) * freq;
	env = EnvGen.ar(Env.adsr(attack, 0.1,0.8,release ),gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);



	SendReply.kr(Impulse.kr(60), "/l1_supersaw7/env", env, replyID);

	// src = SawDPW.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [-1,1].resamp1(7), mul:env );
	src = LFSaw.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [0+modPhase,2].resamp1(7).wrap(0,2), mul:env );

	src = SelectX.ar(mix, [src[3]*0.3, src.sum * 1/7]);
	OffsetOut.ar(out, src*amp!2);

},
metadata:(specs: (detune: ControlSpec(0,10,4), release: ControlSpec(0,2, 2), mix: ControlSpec(0,1), attack: ControlSpec(0,1,2)), oscReplies:["/l1_supersaw7/env"], oscRepliesWithSize:('/l1_supersaw7/env':1) )).add;
// )
// (instrument: \supersaw7, dur: 0.4, freq:36.midicps, amp:1, detune:0.4, release:0.1, mix:300, attack:0, modPhase:0.8).play;
// ~randomMetadataPlay.value(\supersaw7, 200.0, 1)
SynthDef(\l1_fxDucker,
	{
		arg t_duckTrig = 0, decay = 0.2, curve = 0, in = 0, out = 0;
		var sig, env;
		env = Env.perc(0,decay,1,curve).ar(gate:t_duckTrig);
		// env.scope;
		sig = In.ar(in, 2);
		sig = sig * env.linlin(0,1,1,0);
		OffsetOut.ar(out, sig);
	}
).add;


SynthDef(\l1_hoover, {
	arg release = 0.2, riseTime = 0.1, fallTime = 1.7, seed = 44, gate = 1, attack  = 0;
	var snd, freq, bw, delay, decay, env, quitAfter;

	env = Env.adsr(attack, 0.3,1,release).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	RandID.ir(100);
	RandSeed.kr(1,seed);

	freq = \freq.kr(440);
	//change attacks
	freq = freq * Env([-5, 6, 0], [riseTime, fallTime], [\lin, -4]).kr.midiratio;
	bw = 1.035;
	// non random detunes and delays?
	snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(7);
	snd = (Splay.ar(snd) * 3).atan;
	// snd = snd * Env.asr(0.001, 1.0, release).kr(0, \gate.kr(1));
	snd = snd * env;
	// snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
	// snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
	Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;


// (
// {
SynthDef(\l1_12brass,
	{
		arg freq, amp = 1, out = 0, gate = 1, time = 0.3, bendTop = 4, highAmp = 1, replyID = -1;
		var osc, osc2, mods, env, aenv, foldenv, rise, foldenv2, filt, highs, pitchEnv, outmix, quitAfter;

		RandID.ir(100);
		RandSeed.kr(1,226);

		pitchEnv = Env([-5,bendTop,0], [0.04,time/6]).ar(0,1).midiratio;
		aenv = Env.adsr(0.05,0.1,1,0.02).ar(0,gate);
		foldenv = Env.triangle(time/2).ar(0,1);
		foldenv2 = Env.triangle(time/3).ar(0,1);
		rise = Env.new([0,1], [time], 8).ar(0,gate);
		quitAfter = Done.kr(aenv);
		quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
		quitAfter = FreeSelf.kr(quitAfter);



		SendReply.kr(Impulse.kr(60), "/l1_12brass/pitchEnv", pitchEnv, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_12brass/aenv", aenv, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_12brass/foldenv", foldenv, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_12brass/folderEnv2", foldenv2, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_12brass/rise", rise, replyID);


		mods = SinOsc.ar(freq*pitchEnv*1);
		osc = VarSaw.ar((freq *pitchEnv* (Rand(-1,1!4)*0.3).midiratio  + mods.linlin(0,1,0,freq*0)).clip(20,18000), 0,0.5 + mods*0.12);
		osc = Splay.ar(osc) * foldenv.linlin(0,1,1,-1);
		osc = (osc*2).tanh;
		filt = BPF.ar(osc, foldenv2.linlin(0,1,freq,freq*4).clip(20,14000),0.4);
		highs = HPF.ar(osc, 4000, rise*2*highAmp).distort.distort;

		outmix = (filt + highs)*aenv*0.7*AmpCompA.ir(freq)*amp;
		outmix = MidEQ.ar(outmix, freq, 3,-12);
		OffsetOut.ar(out, outmix);
	},
	metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_12brass/folderEnv2","/l1_12brass/folderEnv","/l1_12brass/aenv", "/l1_12brass/pitchEnv", "/l1_12brass/rise"])
).add;
// s.sync;
// (\instrument: \l1_backforth, \freq: 800, \dur: 0.5, \time:0.3).play
// (\instrument: \l1_backforth, \freq: 50, \dur: 0.3, \time: 0.3).play
// (\instrument: \l1_backforth, \freq: 100, \dur: 0.2, \time:0.1).play
// (\instrument: \l1_backforth, \freq: 400, \dur: 0.5, \time:0.3).play

// }.fork;
// )
// Env([-3,3,0], [0.04,0.3], 4).plot
// (
// {
SynthDef(\l1_brassReese,
	{
		arg freq, amp = 1, out = 0, gate = 1, time = 0.3, highAmp = 0, bendTop = 3, replyID = -1;
		var osc, osc2, mods, env, aenv, foldenv, rise, foldenv2, filt, highs, pitchEnv, outmix, quitAfter;

		RandID.ir(100);
		RandSeed.kr(1,30);

		pitchEnv = Env([-3,bendTop,0], [0.04,time/2], 4).ar(0,1).midiratio;
		aenv = Env.adsr(0.05,0.1,1,0.02).ar(0,gate);
		foldenv = Env.sine(time/4).ar(0,1);
		foldenv2 = Env.sine(time/2).ar(0,1);
		rise = Env.new([0,1], [time], 8).ar(0,gate);

		quitAfter = Done.kr(aenv);
		quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
		quitAfter = FreeSelf.kr(quitAfter);


		//OSC replies
		SendReply.kr(Impulse.kr(60), "/l1_brassReese/folderEnv2", foldenv2, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_brassReese/folderEnv", foldenv, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_brassReese/aenv", aenv, replyID);
		SendReply.kr(Impulse.kr(60), "/l1_brassReese/pitchEnv", pitchEnv, replyID);

		SendReply.kr(Impulse.kr(60), "/l1_brassReese/rise", rise, replyID);

		mods = SinOsc.ar(freq*pitchEnv*4);
		osc = VarSaw.ar(freq *pitchEnv* (Rand(-1,1!4)*0.3).midiratio  + mods.linlin(0,1,0,freq*0), 0,0.5 + mods*0.1);
		osc = Splay.ar(osc) * foldenv.linlin(0,1,1,-1).abs;
		osc = (osc*1.5).tanh;
		filt = BRF.ar(osc, foldenv2.linlin(0,1,freq,freq*8).clip(20,10000),2);
		filt = BRF.ar(filt, foldenv2.linlin(0,1,freq*2,freq*0.5).clip(40,10000),1);

		// filt = od
		highs = HPF.ar(osc, 4000, 0.1*highAmp).distort;

		outmix = (filt + highs)*aenv*0.7*AmpCompA.ir(freq)*amp;
		// outmix  = (outmix*2).tanh;

		outmix = MidEQ.ar(outmix, freq, 3,-6);
		// osc2 = VarSaw.ar(freq, 0 ,0.5);

		// osc = SelectX.ar(foldenv, [osc, osc2]);

		OffsetOut.ar(out, outmix);
		// OffsetOut.ar(out, highs*0.25);




	},
	metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_brassReese/folderEnv2","/l1_brassReese/folderEnv","/l1_brassReese/aenv", "/l1_brassReese/pitchEnv", "/l1_brassReese/rise"])
).add;



SynthDef.new(\l1_harmonicWash,{
	arg freq, attack = 0.5, harmOffset = 0, amp = 1, out = 0,release = 2, gate = 1, timeScale = 1, lpf = 500, hpf = 2000, dirt = 0.3, minAmp = 0.32, replyID = -1, leslieSpeed = 2, stereoWidth = 0.3;
	var src, env, mods, freqs, amps, modHighs, moddist, dirtSig, highs, modSpread, quitAfter;
	env = Env.adsr(attack, 0.3,1,release).ar(0,gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// modHighs = Env.new([0,0,[0.5],[0.5],0], [0.1,[0.01,0.1].resamp1(4)], -20, 2,0).ar;
	modHighs  = 0;

	freqs = freq * ([0.5,2.5+harmOffset,3,3.5+harmOffset] + modHighs);
	amps = AmpCompA.kr(freqs, minAmp:minAmp);
	mods = Env.new([1,0,1,0,[1,0.4],0,1,0], [0.05, [0.5,0.4],[0.05, 0.15],0.1,0,0.1,1],releaseNode: 6,loopNode:0).ar(0,1,timeScale:timeScale);
	moddist  = Env([0,1,0,1],[0.3,0.4,0.2], [-5,2], 2,0).ar(timeScale:timeScale);
	modSpread = SinOsc.ar(leslieSpeed).range(-1 * stereoWidth,stereoWidth);

	SendReply.kr(Impulse.kr(60), "/l1_harmonicWash/env", env, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_harmonicWash/mods", mods, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_harmonicWash/moddist", moddist, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_harmonicWash/modSpread", modSpread, replyID);


	freqs[3] = freqs[3] + WhiteNoise.ar().range(-100,100);
	freqs[2] = freqs[2] + WhiteNoise.ar().range(-100,100);
	src = VarSaw.ar(freqs,width: [0.1,0.4].resamp1(4) + mods.linlin(0,1,0.2,0.5),mul:amp*env);
	src = src*amps;
	src  = Splay.ar(src,modSpread)*2;

	dirtSig = (LPF.ar(src, freq.clip(20,16000)) * moddist.linlin(0,1,1,10)*dirt).tanh.excess(0.2);
	dirtSig = HPF.ar(dirtSig, (freq*2).clip(20,16000))*2;

	highs  = HPF.ar(src, hpf);
	src = LPF.ar(src, lpf);
	src = src + dirtSig + highs;


	OffsetOut.ar(out, src);
},
metadata:(specs:(harmOffset: ControlSpec.new(-2.4, 8), attack: ControlSpec.new(0, 10), release: ControlSpec.new(0, 10), timeScale: ControlSpec.new(0, 4), lpf: ControlSpec.new(20, 16000,'exp'), hpf: ControlSpec.new(20, 16000, 'exp'), dirt: ControlSpec.new(0, 2), minAmp: ControlSpec.new(0, 1), replyID: ControlSpec.new(0, 5), stereoWidth: ControlSpec.new(-2, 2), leslieSpeed: ControlSpec.new(0, 20)), oscReplies:["/l1_harmonicWash/env", "/l1_harmonicWash/mods", "/l1_harmonicWash/moddist", "/l1_harmonicWash/modSpread"])
).add;

thisThread.randSeed = 204;

SynthDef.new(\l1fx_mashedVerbPitch,{
	arg amp = 0.1, out, in, gate = 1, verbLen = 0.5, dry=0, replyID = -1, brf = 400, brfq = 2,pitchshiftWindow = 0.4, pitchshift = 12, pitchshiftWet = 1.2, modTime = 0.5, modCurve = -2, hpf = 100, seed = 2930;
	var input, fx, env, verb, modEnv, fall, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	fall = 0.004;
	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	// thisThread.randSeed = 1923;

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	modEnv = Env([0,0,1,0,1,0,0], [0,max((modTime*0.2)-fall, fall),fall,max((modTime*0.8)-fall, fall), fall, fall],modCurve,5,0).ar(0,gate);

	SendReply.kr(Impulse.kr(60), "/l1fx_mashedVerbPitch/modEnv", modEnv, replyID);
	SendReply.kr(Impulse.kr(60), "/l1fx_mashedVerbPitch/env", env, replyID);

	input = In.ar(in,2);
	/*	// thisThread.randSeed = seed;*/

	fx = CheapVerb.ar(input, verbLen,10)*modEnv;
	fx = BRF.ar(fx, brf,brfq);
	fx = fx+ (PitchShift.ar(fx,pitchshiftWindow,SinOsc.ar(0.5).range(pitchshift-0.2,pitchshift+0.2).midiratio).excess(-40.dbamp).distort * pitchshiftWet);
	// fx = fx + FreqShift.ar(fx, [10,-1.5].stutter(2),[0,pi*0.2].stutter(2));
	fx = HPF.ar(fx, hpf);
	Out.ar(out, (fx + (dry*input))*env*amp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1fx_mashedVerbPitch/env", "/l1fx_mashedVerbPitch/modEnv"])
).add;



SynthDef.new(\l1fx_lighterSpace,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1, fall = 0.006, modTime = 0.8, modCurve = 2, lpf = 300, lpfAmp = 0, modDryWet = 1,verbLen = 1, seed = 2930;
	var input, fx, env, verb, ampFollow, ampRescale, modEnv, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	// fall = 0.006;
	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// Done
	modEnv = Env([0,0,1,0,1,0,0], [0,max((modTime*0.2)-fall, fall),fall,max((modTime*0.8)-fall, fall), fall, fall],modCurve,5,0).ar(0,gate);

	SendReply.kr(Impulse.kr(60), "/l1fx_lighterSpace/env", env, replyID);
	SendReply.kr(Impulse.kr(60), "/l1fx_lighterSpace/modEnv", modEnv, replyID);

	input = In.ar(in,2);
	ampFollow = Amplitude.ar(input, 0.001,0.001);


	ampRescale = Sanitize.ar(ampFollow.reciprocal,8).clip(0,8);
	// ampRescale.scope;

	// Normalizer
	// thisThread.randSeed = seed;
	fx = CheapVerb.ar((input*ampRescale).softclip, verbLen,5);
	fx = Splay.ar(fx, 0.9);
	fx = SelectX.ar((1-modEnv)*modDryWet, [fx,( (LPF.ar(fx,lpf)*2).tanh) * DC.ar(lpfAmp)]);

	Out.ar(out, ((dry*input) + fx)*env*amp*0.9);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1fx_lighterSpace/modEnv", "/l1fx_lighterSpace/env"])
).add;


SynthDef.new(\l1_noiseChaos,{
	arg freq, attack=0, subIndex = 0.502, sustainA = 1, decayA = 0.5, decayFenv = 0.6,sawWidth = 0.5, amp = 1, filterIndex = 1, rndAmount = 0.2, out = 0, gate = 1, replyID = -1, seed = 5673, hpf = 20, tanDist = 1;
	var src, src2, env, quitAfter, noise, filt, highs, env2, mix, hp;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);
	env = Env.adsr(attack, decayA,sustainA,0.05,1,-1).ar(0, gate);
	env2 = Env.adsr(0.04, decayFenv,0,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	noise = BrownNoise.ar();
	src = VarSaw.ar(freq + (noise.linlin(-1,1,0,freq*rndAmount)),width:sawWidth, mul:amp*env);
	src2 = VarSaw.ar(freq*subIndex + src.linlin(-1,1,-1 * freq,freq),width:sawWidth,  mul:amp*env);
	filt = DFM1.ar(src+src2, freq*filterIndex + env2.linlin(0,1,0,freq*2) + noise.linlin(-1,1,0,freq) + src2.linlin(-1,1,-1*freq, 1*freq), 0.4,1).tanh.softclip;

	highs = HPF.ar(filt.excess(0.25),1000);
	highs = DelayC.ar(highs, 0.02,SinOsc.ar(5, [0,2pi].resamp1(5)).linlin(-1,1,0.05,0.01));
	highs  = Splay.ar(highs,2);
	highs = HPF.ar(highs, 1000);

	mix = highs + (filt*0.5) + (noise*0.01*env2*amp);

	mix = (mix*tanDist).tanh * env * (tanDist.reciprocal);
	hp = HPF.ar(mix, hpf);


	OffsetOut.ar(out, hp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_samplePlayer,{
	arg freq, amp = 1, rate = 1, attack = 0, transientEnv = 10, decayA = 0.3, sustainA = 1, startPos = 0, transientLen = 0.008, out = 0, gate = 1, replyID = -1, bufnum, tanDist = 1;
	var src, env, quitAfter, envP;
	env = Env.adsr(attack, decayA,sustainA,0.05,1,-2).ar(0, gate);
	envP = Env([0,1,0],[0,transientLen], -4).ar(0,gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	src = PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum)*rate + (envP*transientEnv),loop:0, startPos:startPos) * env * amp;
	tanDist  = max(tanDist,1);
	src = (src * tanDist).tanh * (tanDist.reciprocal);
	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	// src = SinOsc.ar(freq, mul:amp*env);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1fx_simpleVerb,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1;
	var input, fx, env, verb, quitAfter;
	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	// fx = CheapVerb.ar(input, 0.4,20);
	fx = FreeVerb.ar(input, 1);

	Out.ar(out, ((dry*input) + fx)*env*amp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1fx_reverseAmp,{
	arg amp = 1,attackTime = 0, curve = 2, out = 0, in = 0, gate = 1, dry=0, replyID = -1;
	var input, fx, env, verb, quitAfter;
	env = Env.adsr(attackTime, 0.3,1,0.05,1,curve).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	fx = CheapVerb.ar(input, 0.4,20);

	Out.ar(out, ((dry*input) + fx)*env*amp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_LaserSync,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, syncFactor = 1, modSync = 1, lfoSpeed = 5, attack = 0;
	var src, env, quitAfter, mod;
	env = Env.adsr(attack, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	mod = SinOsc.ar((freq*1)+lfoSpeed);

	src = SyncSaw.ar(freq, freq*syncFactor * mod.linlin(-1,1,1,1 + modSync), mul:amp*env*0.5);
	src = src +  LPF.ar(SyncSaw.ar(freq * 0.5, freq*0.5, mul:amp*env * 0.5), (freq*2).clip(20, 10000));
	// src = SinOsc.ar(freq, mul:amp*env);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;
// s.sync;


SynthDef.new(\l1_fullBass,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, harm1 = 2,  harm2 = 4, excess = 0.01, duckT = 0.04;
	var src, env, quitAfter, envy, envy2, ducks, nEnv;
	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	envy = Env.new([0,1,0.4,0.1], [0.01,0.2, 0.1], 4).ar(0,1);
	envy2 = Env.new([0,1,1,0.1], [0.1,0.2,0.1]).ar(0,1);
	nEnv = Env.new([0,1,0.4,0.1], [0.2,0.1,0.1]).ar(0,Impulse.ar(1));

	ducks = Env.new(1-[1,1,0,1], [duckT,0.05,0.04], [4,-4]).ar(0,1);

	src = SinOscFB.ar(freq,envy*0.3 +ducks, mul:amp*env*envy);
	src = src + SinOscFB.ar(freq*2,envy2*0.3 +ducks, mul:amp*env*envy2);
	src = src*(1-ducks);
	src = src + VarSaw.ar(freq * harm1, 0, SinOsc.ar(freq * 0.125).range(0.4,0.6), 0.02 * nEnv.linlin(0,1,1,0));
	src = src + VarSaw.ar(freq * harm2, 0, SinOsc.ar(freq * 0.125).range(0.4,0.6), 0.02*DelayN.ar(nEnv,0.1,0.02));
	src = BRF.ar(src, nEnv.linlin(0,1,500, 2000), 1);
	src = src + src.excess(excess);
	src = Normalizer.ar(src, 0.8);
	// src = (src*2).tanh;
	src = src *env * amp;
	// src = src + ((DFM1.ar(src, (freq*4) + src.linlin(0,1,0,freq*4), 0.7,2,1)*4).distort * 0.08);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_deepbass,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, clockTempo = 1, sub = 1;
	var src, filt, warmLow, subSig, pulseEnv, lfo,mix1, chorus, env, quitAfter;
	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	pulseEnv = LFSaw.ar(2 * clockTempo, 1);

	SendReply.kr(Impulse.kr(60), "/l1_deepbass/pulseEnv", pulseEnv, replyID);

	lfo = LFSaw.ar(0.125*0.5 * clockTempo, 1);
	src = SyncSaw.ar(freq, pulseEnv.range(freq*0.5,freq*1.5).lag(0,0), mul:lfo.range(0.2,1));

	// src = (src.clip(-1,1).pow(4) * 10).tanh;
	src= CrossoverDistortion.ar(src, 0.2,SinOsc.ar(freq*0.5).range(0.1,0.8));
	src = (src * 10).tanh;
	src = Sanitize.ar(src);
	filt = DFM1.ar(src, 1000 + src.linlin(0,1,0,4000), 0.96, 0.1, 1);
	filt = filt+ AllpassL.ar(filt, 0.2, 2*(freq.reciprocal),SinOsc.ar(0.125 * 0.25).range(0.1,1.2));
	filt = HPF.ar(filt * Env.asr(0.004,1,1).ar(0,1), 5000);
	filt = Sanitize.ar(filt);
	warmLow = LPF.ar(src,200, 2).tanh * 0.7;
	warmLow = HPF.ar(warmLow, 110);
	warmLow = HPF.ar(warmLow, 110);
	warmLow = HPF.ar(warmLow, 110);

	subSig = SinOsc.ar(freq*0.5 + pulseEnv.lincurve(-1,1,freq * 0.2, 0,-10), 0,0.2) * sub;
	mix1 = warmLow + filt + subSig;


	chorus = CombL.ar(mix1, 0.2, SinOsc.ar([freq * 0.5,(freq*0.5) + 0.1]).range(1,2) * freq.reciprocal * 1, freq.reciprocal*10);
	chorus =CombL.ar(chorus, 0.02,freq.reciprocal,freq.reciprocal * 5);
	chorus = Splay.ar(chorus, 0.9);
	// chorus = HPF.ar(chorus, 400);
	chorus = BPF.ar(chorus, 1000,1)  *  LFSaw.ar(0.5, 1).lincurve(-1,1,0.01,1,1);

	// chorus = LPF.ar(chorus, 900);

	mix1= mix1 +chorus;
	mix1 = env * mix1 * amp;



	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	// src = SinOsc.ar(freq, mul:amp*env);

	OffsetOut.ar(out, mix1);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_deepbass/pulseEnv"])
).add;

SynthDef.new(\l1fx_bpsEnved,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673, fq = 0.1, minF = 500, maxF = 1800, speedMax = 15, speedMin = 2, speed = 0.3, dropTime = 0.1, volCurve = 10, duckT = 0.04, duck = 0, duckLen =0.09 ;
	var input, fx, env, verb, quitAfter, freqs, volumes, sineF, moveFs, ducks;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	ducks = Env.new(1-[1,1,0,1], [duckT,duckLen*0.555,duckLen*0.444], [4,-4]).ar(0,1);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/env", env, replyID);


	input = In.ar(in,2);
	//
	moveFs = Env.pairs([[0,1],[dropTime,1], [dropTime+0.1,0.2]],0).ar(0,1).lag(0,[0,0.1,0.02,0.5]);

	// freqs = LFNoise1.ar(9).range([0,1].resamp1(8).stutter(2).linexp(0,1,100,8000), [0,1].resamp1(8).stutter(2).linexp(0,1,300,12000));
	freqs = [0,1].resamp1(6).linexp(0,1,minF,maxF) * moveFs;
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/freqs", freqs, replyID);

	sineF = Env.perc(0,speed,1,-2).ar(0,1).linlin(0,1,speedMin,speedMax);
	volumes = SinOsc.ar(sineF, [0,2pi].resamp1(6));
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/rawVolumeLFO", volumes, replyID);
	volumes = volumes.lincurve(-1,1,0.01,1,volCurve);
	// volumes.scope;
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/volumes", volumes, replyID);

	fx = BPF.ar(input,freqs.clip(20,12000).stutter(2), fq.clip(0.1,1), fq.linlin(0.1,1, 3,0.5) * 1*(volumes.stutter(2)));
	fx = Mix.new(fx);

	Out.ar(out, ((dry*input) + fx)*env*amp * (1-(ducks*duck.clip(0,1))));
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1fx_bpsEnved/freqs", "/l1fx_bpsEnved/volumes","/l1fx_bpsEnved/rawVolumeLFO", "/l1fx_bpsEnved/env", "/l1fx_bpsEnved/ducks"])
).add;


SynthDef.new(\l1_simpleSines,{
	arg freq, amp = 1,pulseRate = 2, attack = 3, release = 3, out = 0, gate = 1, replyID = -1, pan = 0;
	var src, env, quitAfter, pulse, div, compensate;
	env = Env.adsr(attack, 0.3,1,release,1,2).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	pulse = Impulse.ar(pulseRate);
	div = ToggleFF.ar(pulse);

	pulse = Env.perc(0,0.2,1,0).ar(0,pulse);
	compensate = AmpCompA.ar(K2A.ar([freq, freq*2]));
	SendReply.kr(Impulse.kr(60), "/l1_simpleSines/env", env, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_simpleSines/pulse", pulse, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_simpleSines/div", div, replyID);

	src = SinOscFB.ar([freq, freq*2 * pulse.lincurve(0,1,1,1.06,20) * div.linlin(0,1,1,1.01)],0.2, mul:[pulse.lag(0.02,0).lincurve(0,1,1,0, -1),1]*amp*env*compensate*0.4).sum;

	src = Pan2.ar(src, pan);

	OffsetOut.ar(out, src);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_simpleSines/env", "/l1_simpleSines/pulse", "/l1_simpleSines/div"])
).add;


SynthDef.new(\l1fx_pitchWave,{
	arg amp = 1, out = 0, in = 0,dropTime = 3, gate = 1, dry=0, replyID = -1,  seed = 5673;
	var input, fx, env, verb, quitAfter, delay, delayEnv;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);

	delayEnv = Env.pairs([[0,1],[dropTime,0]], 0).ar(0,Impulse.ar(1));
	delay = DelayC.ar(input, 0.2,delayEnv.lincurve(0,1,0,0.2, [-1,-2,-3].stutter(2)),0.3);
	delay = Mix.new(delay);
	fx = delay;
	// fx = CheapVerb.ar(input, 0.4,20);

	Out.ar(out, ((dry*input) + fx)*env*amp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_moreSyncSaw,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, syncFactor = 1, modSync = 1, lfoSpeed = 5, attack = 0;
	var src, env, quitAfter, mod;
	env = Env.adsr(attack, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	mod = SinOsc.ar((freq*1)+lfoSpeed);

	src = SyncSaw.ar(freq, freq*syncFactor * mod.linlin(-1,1,1,1 + modSync), mul:amp*env*0.5);
	src = src +  LPF.ar(SyncSaw.ar(freq * 0.5, freq*0.5, mul:amp*env * 0.5), (freq*2).clip(20, 10000));
	// src = SinOsc.ar(freq, mul:amp*env);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_digitoneV2,{
	arg freq, amp = 1, lineLen = 0.8, brF = 0.5, transientAmt = 0.14, lfoSpeed= 5, out = 0, gate = 1, replyID = -1, release = 0.1;
	var src, env, quitAfter, envLin, transient, lfo;
	env = Env.adsr(0.0, 0.3,1,release,1,-1).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	transient = Env.perc(0,0.015,transientAmt,-1).ar(0,1);

	src = SinOsc.ar(freq * transient.linlin(0,1,1,10), mul: 1/10 );
	src = src * SinOsc.ar((src * 20000) + freq*2.12 + transient.linlin(0,1,0,11000), mul: 1);
	src = src.excess(SinOsc.ar(20 + transient.linlin(0,1,0,1000)));
	envLin = Env.perc(0,lineLen,1,-1).ar(0,1);
	src  = ((src * 20 - (envLin * 15) + transient.linlin(0,1,0,30)).tanh *0.1 ) + src;

	src = LeakDC.ar(src) * amp;
	lfo =  SinOsc.ar(lfoSpeed);
	src = BRF.ar(src, (brF.linlin(0,1,200,800) + lfo.linlin(-1,1,-900,900) + envLin.lincurve(0,1,0,1000,10) + transient.linlin(0,1,0,2000)).clip(100,12000), 4);
	src = src.clip(-1,1)*env;
	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_reeseDouble,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, timeScale = 1, tempoScale = 1, agression = 1, lpfFactor = 1, subOsc = 0, modFreqFactor = 1.5;
	var  env, quitAfter, osc, modOsc, outBus, lowFilt, env1, lfo1, lfo2, lfo3, env2, highBus, midBus, sub;

	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);





	// src = SinOsc.ar(freq, mul:amp*env);

	env1 = Env.perc(0,0.7,1,0).ar(0,1, timeScale: timeScale);
	env2 = Env.perc(0,2,1,0).ar(0,1, timeScale: timeScale);
	// lfo1 = Env.perc(0,2,1,0).ar(0,1, timeScale: timeScale);
	lfo1 = LFPulse.ar(2 * tempoScale);
	lfo2 = Env.new([0,1,0.4,0.6,0.1,0.4,0,0], [0.1,0.1,0.3,0.2,0.1,0.2,0],[0,6,2,-4,-7,-4,-4,0] , releaseNode:6, loopNode:0).ar(0,1, timeScale:2 * timeScale);
	lfo3 = Env.new([ 0, 0.6, 0, 0.4, 1, 0, 0.1, 0.4 ], [0.1,0.1,0.3,0.2,0.1,0.2,0],[0,6,2,-4,-7,-4,-4,0] , releaseNode:6, loopNode:0).ar(0,1, timeScale:2 * timeScale);


	SendReply.kr(Impulse.kr(60), "/l1_reeseDouble/env1", env1, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseDouble/env2", env2, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseDouble/lfo1", lfo1, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseDouble/lfo2", lfo2, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseDouble/lfo3", lfo3, replyID);

	sub = SinOsc.ar(freq*0.5);
	modOsc = SinOscFB.ar(freq*modFreqFactor, env2.linlin(0,1,1,0));
	osc = SyncSaw.ar(freq ,(freq * env1.linlin(0,1,1,5) )+ (modOsc.linlin(-1,1,lfo1.lag(0.01).range(0,-4)*freq, lfo1.lag(0.1).range(1,5)*freq)*agression), mul:0.5);

	osc = osc + (sub*subOsc);
	lowFilt = DFM1.ar(osc, (freq* lfo3.linlin(0,1,0.8,3) *lpfFactor)+ osc.linlin(0,1,0*freq, 2*freq),0.9 * agression, 0.9,0).tanh;

	highBus = osc * 0.1;

	highBus = BRF.ar(highBus, lfo3.lag(0.2).linlin(0,1,2000,400),2);
	highBus = BRF.ar(highBus, lfo3.linexp(0,1,1000,10000),1) * lfo2.lincurve(0,1,0.05,1, 2);
	highBus = DelayL.ar(highBus, 0.1, lfo3.linlin(0,1,0,0.03));
	highBus = CombL.ar(highBus, 0.1,freq.reciprocal + highBus.linlin(-0.2,0.2,-0.002,0.002),0.7);



	outBus = (lowFilt*0.4 * lfo3.linlin(0,1,1,0.5)) + highBus;
	outBus = LRLowCut.ar(outBus , 100,4,4);
	outBus = (outBus * amp*env);

	outBus = LeakDC.ar(outBus);

	OffsetOut.ar(out, outBus!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_reeseDouble/env1","/l1_reeseDouble/env2", "/l1_reeseDouble/lfo1", "/l1_reeseDouble/lfo2", "/l1_reeseDouble/lfo3"])
).add;

SynthDef.new(\l1_reeseLightHighs,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, attack= 0.01, ampCurve = -4, timeScale = 1, tempoScale = 1, agression = 0, subOsc = 1, modFreqFactor = 1, modOffset = 0, invertEnv = 0, dilateEnv = 0.1, bpf = 400, bpfVol = 1;
	var  env, quitAfter, osc, modOsc, outBus, lowFilt, env1, lfo1, lfo2, lfo3, env2, highBus, midBus, sub, comp;

	env = Env.adsr(attack, 0.3,1,0.05,1,ampCurve).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);





	// src = SinOsc.ar(freq, mul:amp*env);

	dilateEnv = ([-0.1,0.124,0.022,-0.275] * dilateEnv);
	dilateEnv = ([0.1,0.1,0.3,0.2,0.1,0.2,0] + dilateEnv).abs;

	env1 = Env.perc(0,0.7,1,0).ar(0,1, timeScale: timeScale);
	env2 = Env.perc(0,0.1,1,0).ar(0,1, timeScale: timeScale);
	// lfo1 = Env.perc(0,2,1,0).ar(0,1, timeScale: timeScale);
	lfo1 = LFPulse.ar(2 * tempoScale);
	lfo2 = Env.new([0,1,0.4,0.6,0.1,0.4,0,0].linlin(0,1,invertEnv.lincurve(0,1,0,1,2), invertEnv.lincurve(0,1,1,0,-8)), dilateEnv, [0,6,2,-4,-7,-4,-4,0]+modOffset , releaseNode:6, loopNode:0).ar(0,1, timeScale: timeScale);
	lfo3 = Env.new([ 0, 0.6, 0, 0.4, 1, 0, 0.1, 0.4 ].linlin(0,1,invertEnv.lincurve(0,1,0,1,4), invertEnv.lincurve(0,1,1,0,-5)), dilateEnv, [0,6,2,-4,-7,-4,-4,0]+modOffset , releaseNode:6, loopNode:0).ar(0,1, timeScale: timeScale);


	SendReply.kr(Impulse.kr(60), "/l1_reeseLightHighs/env1", env1, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseLightHighs/env2", env2, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseLightHighs/lfo1", lfo1, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseLightHighs/lfo2", lfo2, replyID);
	SendReply.kr(Impulse.kr(60), "/l1_reeseLightHighs/lfo3", lfo3, replyID);

	sub = SinOsc.ar(freq*0.5);
	modOsc = SinOscFB.ar(freq*modFreqFactor, env2.linlin(0,1,1,0));
	osc = SyncSaw.ar(freq ,(freq * env1.linlin(0,1,1,5) )+ (modOsc.linlin(-1,1,lfo1.lag(0.01).range(0,-4)*freq, lfo1.lag(0.1).range(1,5)*freq)*agression), mul:0.5);

	osc = osc + (sub*subOsc);

	highBus = osc * 0.1;

	highBus = BRF.ar(highBus, lfo3.lag(0.2).linlin(0,1,2000,100),2);
	highBus = BRF.ar(highBus, lfo3.lincurve(0,1,1000,5000, 30),3) * lfo2.lincurve(0,1,-10.dbamp,1, 1);
	highBus = DelayL.ar(highBus, 0.1, lfo3.linlin(0,1,0,0.03));
	highBus = CombL.ar(highBus, 0.1,freq.reciprocal + highBus.linlin(-0.2,0.2,-0.002,0.002),0.2);




	outBus = highBus;
	outBus = highBus + BPF.ar(osc, (bpf * lfo2.lag(0.2,0).linlin(0,1,1.2,1)).clip(50,10000), 0.4,0.1*bpfVol).distort;

	outBus = LRLowCut.ar(outBus , 140,5,5);
	// comp = Peak.ar(outBus).poll.reciprocal.sanitize;
	comp = outBus.abs.lag(0.008,0.005).reciprocal.sanitize;
	comp = (outBus * comp * 0.1).tanh.clip(-1,1);

	outBus = outBus + (comp * 0.05);

	outBus = LeakDC.ar(outBus);
	outBus = (outBus * amp*env);



	OffsetOut.ar(out, outBus!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_reeseLightHighs/env1","/l1_reeseLightHighs/env2", "/l1_reeseLightHighs/lfo1", "/l1_reeseLightHighs/lfo2", "/l1_reeseLightHighs/lfo3"])
).add;


SynthDef.new(\l1_clusterKick,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, release = 0.05, clusterPunch = 0, clusterOffset = 0.1, lpf = 400, sub = 1, ring=1, transient = 1, transientPDur = 0.01, transientADur = 0.07;
	var src, env, quitAfter, aEnv, pEnv, cluster, clusterHighs, clusEnv;
	env = Env.adsr(0, 0.3,1,release,1,-4).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	aEnv = Env.new([0,1,0.5*sub,0], [0.0001,transientADur,0.5], -2).ar(0,1);
	pEnv = Env.new([1,20*transient,2,1], [0.00001,transientPDur,0.3], -5).ar(0,1);
	clusEnv = Env.new([0,1,0.1,0], [0.0001,0.1,0.5], -2).ar(0,1);


	cluster = SinOsc.ar(freq*pEnv.linlin(1,20,1,clusterPunch.linlin(0,1,2,4))*([1,1.2,1.8,2.2,3.4]+clusterOffset)*2,mul:0.1*clusEnv).sum;
	cluster = CombL.ar(cluster, 0.1, ((freq.reciprocal*0.50)+ SinOsc.ar(freq*1).range(-0.001,0.0001)).clip(0.0001,0.1),ring.linlin(0,1,0.5,1.4));
	cluster = CombL.ar(cluster, 0.1, ((freq.reciprocal*0.50)+ SinOsc.ar(freq*1).range(-0.001,0.006)).clip(0.0001,0.1),ring.linlin(0,1,0.01,0.2));

	clusterHighs = LRLowCut.ar((cluster.excess(-70.dbamp)*20.dbamp).tanh + cluster,500, 5,5);
	clusterHighs = LPF.ar(clusterHighs, lpf);
	cluster = LRHiCut.ar((cluster.excess(-50.dbamp)*20.dbamp).tanh + cluster,200, 3,3);

	cluster = LRLowCut.ar(cluster+clusterHighs, freq * 3,5) * 0.4;
	cluster = (cluster*2).softclip() * 2.reciprocal;

	src = SinOsc.ar(freq*pEnv, mul:aEnv);


	src = ( src + cluster) * amp*env;

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(release:ControlSpec.new(0.05, 2), clusterPunch:ControlSpec.new(0, 1), clusterOffset:ControlSpec.new(0, 4), lpf:ControlSpec.new(20, 20000,'exp'), sub:ControlSpec.new(0, 1,1), ring:ControlSpec.new(0, 1), transient:ControlSpec.new(0, 1), transientPDur:ControlSpec.new(0.001, 0.1,1), transientADur:ControlSpec.new(0.001,0.2,1)), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_decayKick,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, release = 0.05, sub = 1, transient = 1, transientPDur = 0.01, transientADur = 0.1;
	var src, env, quitAfter, aEnv, pEnv;
	env = Env.adsr(0, 0.3,1,release,1,-4).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);



	aEnv = Env.new([0,1,0.8*sub ,0], [0.0001,transientADur,0.5], -2).ar(0,1);
	pEnv = Env.new([1,50*transient,2,1], [0.00001,transientPDur,0.3], -5).ar(0,1);

	SendReply.kr(Impulse.kr(60), "/l1_decayKick/aEnv", env, replyID);

	src = SinOsc.ar(freq*pEnv, mul:aEnv*amp*env);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_decayKick/aEnv"])
).add;


SynthDef.new(\l1_bendSub,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, timeScale = 1, subCurve = -2, topFreq = 60, bottomFreq = 20;
	var src, env, quitAfter, sub, fenv, aenv;
	env = Env.adsr(0.01, 0.3,1,0.06).ar(0, gate);


	fenv  = Env.pairs([[0,20], [0.1, topFreq], [0.3,0.5.linlin(0,1,bottomFreq, topFreq) ], [0.5,bottomFreq]], subCurve).ar(0,1,timeScale);
	aenv = Env.pairs([[0,0.2], [0.1, 1], [0.3,0.4], [0.35,1], [0.45,0.1]], 0).ar(0,1,timeScale);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	sub = SinOsc.ar(fenv, mul:aenv*env*amp);
	sub = LRHiCut.ar(sub,80,5,5);

	OffsetOut.ar(out, sub!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_rollerBass,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1, rise1 = 0.3, rise2 = 1, rise2Time = 0.6, compRoot = 24, attack = 0.2;
	var src, env, quitAfter, bass, phases, freqs, dirt, outBass, revAmp, rise2Env;
	env = Env.adsr(attack, 0.3,1,0.05).ar(0, gate);
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	revAmp = Env.perc(0.5,0.05,rise1,0.5).ar(0,1);
	rise2Env = Env.adsr(rise2Time, 0.3,1,0.05,rise2,2).ar(0, gate);

	freqs = {arg i; thisThread.randSeed = i; freq* rrand(-0.5,0.5).round(0.25).midiratio.postln}!8;
	// freqs = {arg i; freq * i.postln.lincurve(0,7,-2,2,0).midiratio}!8;

	phases = {arg i; thisThread.randSeed = i; rrand(0,1.0).postln}!8;

	// freq.postln;
	bass = LFSaw.ar(freqs, phases, mul:8.reciprocal * env).sum;
	bass = LRHiCut.ar(bass,250, 5,5);
	bass = LRLowCut.ar(bass, 80, 5,5);

	dirt = (bass*revAmp.linlin(0,1,1,10)).tanh;

	dirt = LRLowCut.ar(dirt,  (freq*5).clip(20,20000),5,5);
	// dirt = AllpassL.ar(dirt, 0.1, LFTri.ar(5).range((100).reciprocal, (5000).reciprocal), 2) + dirt;
	dirt = CombL.ar(dirt, 0.2,(freq*16).reciprocal,0.05);
	dirt = dirt + LPF.ar(HPF.ar(dirt.wrap(-0.04,0.04),freq*2),(freq * 32).clip(20,20000), 0.1);
	// dirt = AllpassL.ar(dirt, 0.1, LFSaw.ar(freq/2).range((freq*4).reciprocal, (freq*8).reciprocal), 0.9) + dirt;
	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	outBass = bass + dirt;
	outBass = outBass + LPF.ar(HPF.ar((outBass*LFSaw.ar(freq*1.041).range(1,20)).softclip,400, 0.3),800,0.2*rise2Env);
	outBass = outBass * AmpCompA.ir(freq,compRoot.midicps,0.1) * env*amp;
	// src = SinOsc.ar(freq, mul:amp*env);

	OffsetOut.ar(out, outBass!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_trigToBus,{
	arg trigOut = 0, gate = 1, replyID = -1, trigOn = 1;
	var src, env, quitAfter, trig;

	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	trig = Impulse.ar(0) * trigOn;

	// quitAfter = Done.kr(env);
	// quitAfter = DelayN.kr(trig, 2/60, 2/60);// twoframe delay
	// quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	OffsetOut.ar(trigOut, trig);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_riserBass,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, time = 5, waveShapeOffset = 0, riseSpeed = 0.4, waveShapeMul = 1, hiModAmp = 1, lowCutoff = 200, hiCutOff = 6000, midOsc = 0.2, hiOsc=0, startVolume = 0.1;
	var osc, buf, dist, dist2, env, env2, env3, fmOsc, hiMod, buf2, times, trig, pitchEnv, riser1, bus, envAmp, quitAfter;
	envAmp = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(envAmp);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);
	riser1  = Sweep.ar(0,riseSpeed );



	buf = LocalBuf.newFrom(Env.pairs([[0,0], [0.1,-1], [0.5,0], [0.6,1], [1,0]],10 * [-1,0.1]).asSignal(256).asWavetable);
	times = [ 0.01, 0.01, time, 0.02, 0.02, 0.732, 2.604 ];
	trig = Impulse.ar(time.reciprocal);

	pitchEnv = Env.new([0,0,1],[0.00001,time]).ar(0,trig);

	env = Env.new([ 20, 14, 6, 1, 20, 20, 2, 14 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ]* 0.1);
	env2 = Env.new([ startVolume, startVolume, startVolume, 1, 1, 1, 1, 1 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ].abs * -0.1).ar(0,1);
	env3 = Env.new([ 0, 0, 0, 1, 0, 0, 0, 0 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ]).ar(0, trig);



	env = env.ar(0,trig,timeScale:0.8);
	osc = SinOsc.ar(freq * [1,8,16] * riser1.linlin(0,20,0,[12,12,12],nil).midiratio , mul:env * [1,midOsc, hiOsc]).sum;
	osc = LRHiCut.ar(osc, 1000);
	dist = Shaper.ar(buf, ((osc*waveShapeMul)+waveShapeOffset));

	// dist  = dist.ring1(fmOsc*0.12);


	hiMod = AllpassL.ar(dist, 0.2,[2,1,0.5,1.5]*1 * freq.reciprocal * dist.linlin(-1,1,-12,12).lag(0.001).midiratio,5 );
	hiMod =dist + Splay.ar(hiMod,0.4);

	hiMod = HPF.ar(hiMod, 1000) * hiModAmp;

	dist = Normalizer.ar(LRHiCut.ar(dist, lowCutoff, 5,5),0.5,freq.reciprocal*2)+ LRLowCut.ar(dist, hiCutOff, 5,5);
	bus = (hiMod + dist)*env2;

	bus = LRHiCut.ar(Shaper.ar(buf, bus +0.2,0.4),2000,7,7) +bus;
	// bus = FreeVerb.ar(bus,0.4,0.9,0.1,mul:1*envAmp*amp);
	bus = bus*envAmp*amp*0.3;


	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	OffsetOut.ar(out, bus!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_gruntStab,{
	arg freq = 130.81, amp = 1, out = 0, gate = 1, replyID = -1, combBase = 4000, pmBase = 0.2, attack = 0.06, modRatio = 0.5, pmFall = 0.04;
	var src, env, quitAfter;
	var bass, envA, envPm, envPm2, hi;

	// trig = Impulse.ar(8);


	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);



	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	envA  = Env.pairs([[0,0], [attack,1], [0.4,0]], [0,-2]).ar(0,1);

	envPm = Env.pairs([[0,0], [0.03,1], [0.03+pmFall,0]], [2,-2]).ar(0,1);
	envPm2 = Env.pairs([[0,0], [0.06,0],[0.1,1], [0.07,1]], [4,-2]).ar(0,1);

	bass =SinOsc.ar(freq, LFTri.ar(freq*modRatio).range(0,2*pi)*envPm.lincurve(0,1,pmBase,5,0) , envA) ;
	bass = bass+ bass.excess(0.25);
	bass = bass.softclip;

	hi = LRLowCut.ar(bass,1000).excess(0.02)*4;
	hi = DelayL.ar(hi, 0.1,{arg i; (i+1).pow(2)*combBase.reciprocal}!4).sum + hi;


	bass = (bass + hi)*env*amp;
	// bass = (bass  )*env;


	OffsetOut.ar(out, bass!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_hiHit,{
	arg freq = 2000, amp = 1, out = 0, gate = 1, replyID = -1, seed = 9434;
	var src, env, quitAfter;
	var osc, aenv;
	// trig = Impulse.ar(8);
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);



	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);


	aenv = Env.perc([0.002,0.001],[0.03,0.06], [1,0.4], [-1,-8]).ar(0,1);
	osc = SinOsc.ar([freq, freq*6.56], mul: aenv*amp).sum!2;

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	OffsetOut.ar(out, osc);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;



SynthDef.new(\l1_laSnare,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1,seed = 5, noiseDecay = 0.09, filterDecay = 0.09, tunedFreq = 129,notchF1 = 1400,notchF2 = 5000, noisePlateau = 0.05;
	var src, env, quitAfter,noiseEnv, filtEnv;
	env = Env.adsr(0, 0.3,1,0.05).ar(0, gate);

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);


	noiseEnv = Env.pairs([[0,0.0],[0.00000001,1], [0.04,noisePlateau],[0.06 + noiseDecay,noisePlateau], [0.11 + noiseDecay,0]], -4).ar(0,1);
	filtEnv = Env.pairs([[0,20000],[0.00001,20000], [filterDecay,tunedFreq],[0.2,tunedFreq], [0.4,tunedFreq]], -15).ar(0,1);
	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	src = WhiteNoise.ar( mul:env*noiseEnv);
	src = BRF.ar(src, notchF1,1);
	src = BRF.ar(src, notchF2,0.3);

	// src= LRLowCut.ar(src, filtEnv,5,5).sanitize.clip(-1,1);
	src= DFM1.ar(src, filtEnv,0.98,1,1,mul:4).sanitize.tanh.clip(-1,1) * amp;

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_leKick,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1,seed = 9435, kickLen = 0.2;
	var src, env, quitAfter, kickEnv,kickEnvA, click;
	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	click = Impulse.ar(0);

	click =click + DelayL.ar(click,0.1,0.0002,-1) + DelayL.ar(click,0.1,0.0092,-0.5);


	kickEnv = Env.pairs([[0,1],[0.0000001,12], [0.02,2],[0.06,1.2], [0.09,1]], -2).ar(0,1);
	kickEnvA = Env.pairs([[0,1],[0.0000001,1], [kickLen,0.6],[kickLen+0.05,0]], -2).ar(0,1);
	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	src = SinOsc.ar( freq*kickEnv, mul:kickEnvA);

	src = (src + click)*amp*env;
	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_clumpSnare,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, delaySpread = 1, delayRotate = 0, rollAmp = 1, rollSpeed = 19.23, seed = 239, rollDecay = 0, freqshiftAmp = 0.5, freqshift = 1000, noise = 0;
	var src, env, quitAfter, pitchEnv, trig, ampEnv, combEnv, noiseEnv;
	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	// trig = TDelay.ar(Impulse.ar(0), [0,1].resamp1(4).lincurve(0,1,0.0,0.04,-2));
	trig = Impulse.ar(0);
	pitchEnv = Env.new([0,1,0.2,0], [0.0000001,0.006,0.02],[-6,-2]).ar(0,trig);
	ampEnv = Env.perc(0,[0.2,0.1,0.2,0.2], 1,[-4,-2,-1,-10]).ar(0,trig);
	noiseEnv = Env.perc(0,[0.2,0.1,0.2,0.2]*0.6, 1,[-4,-2,-1,-10] ).ar(0,trig);


	src = SinOsc.ar(freq * [1.0, 2.76, 5.40, 8.90] * pitchEnv.linlin(0,1,0,7*12).midiratio, mul:amp* ampEnv*env * 1/4  * [0.6,0.4,0.3,0.1]*2);
	src = src + BRF.ar(WhiteNoise.ar(noiseEnv*0.05), [1000,2000,3000,4000],0.4,noise);
	// src = src + Impulse.ar(0,mul:-0.3);
	// src = DelayN.ar(src, 0.2, [0,1].resamp1(4).lincurve(0,1,0.08,0,-4)).sum;
	src = DelayN.ar(src, 0.2, ([0,0.01,0.004,0.05].rotate(0)*delaySpread).abs).sum;

	// combEnv = Env.perc(0,0.1,1,-6).ar(0,1);
	src = src+ DelayN.ar(HPF.ar(CombL.ar(src, 0.2,0.009,0.06,mul:0.2),1000),0.2,0.05);
	src = src+ HPF.ar(CombL.ar(src, 0.2,rollSpeed.reciprocal,rollDecay,mul:0.05 * rollAmp),100);

	src = src+ FreqShift.ar(src,freqshift,mul:freqshiftAmp);
	src = src*2;
	src = LRLowCut.ar(src,200,4,4);
	src = src.clip(-1,1);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef(\l1_supersaw7V2, {
	arg freq = 1000, detune = 0.3, release = 0.2, mix = 0.4, amp = 1, out = 0, gate = 1, attack = 0, modPhase = 0, pitchbend = 0, replyID = -1, pitchLen = 0.5, pitchAmt = 5, dip=1, dipEnd = 0.4, dipLen = 0.4, centerRatio = 1, pan = 0;
	var src, env, paned, pitchEnvs, srcTuned, dipEnv, voices;

	voices = 4;

	freq = (pitchbend.midiratio) * freq;
	env = EnvGen.ar(Env.adsr(attack, 0.1,0.8,release ),gate, doneAction:2);

	SendReply.kr(Impulse.kr(60), "/l1_supersaw7V2/env", env, replyID);

	pitchEnvs = Env.pairs([ [ 0.0, 0 ], [ 0.01, 1.0 ], [ 0.2, 0.1 ], [ 0.33, 0.02 ], [ 0.51, 0.1 ], [ 0.82, 0.13 ], [ 0.89, 0.05 ], [ 1.0, 0.0 ] ], [ 2.3, -3.4, -3.6, -1.1, -3.2, 1.7, -3.3, 3.0 ] * -1);
	pitchEnvs = pitchEnvs.ar(0,1,[1,1].resamp1(voices) * pitchLen);

	SendReply.kr(Impulse.kr(60), "/l1_supersaw7V2/pitchEnv", pitchEnvs[0] * pitchAmt, replyID);

	dipEnv = Env.perc(0,dipLen,1,4).ar(0,1);
	dipEnv = DelayN.ar(dipEnv,dipEnd,[0.03,dipEnd].resamp1(voices));

	// src = SawDPW.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [-1,1].resamp1(7), mul:env );
	src = LFSaw.ar(freq * [-1*detune,detune].resamp1(voices).midiratio *(pitchEnvs*[1,-1].resamp1(voices) * pitchAmt).midiratio, [0+modPhase,2].resamp1(7).wrap(0,2), mul:env );
	src = src *dipEnv.linlin(0,1,1,1-dip);
	// dipEnv.scope;

	srcTuned = LFSaw.ar(freq *centerRatio*(pitchEnvs[0] * pitchAmt).midiratio, 0, mul:env * (1/(centerRatio.linlin(1,16,1,4,nil))).clip(0,1) );
	src = SelectX.ar(mix, [srcTuned*1/3, src.sum * 1/((voices+1)*0.6)]);
	src= src.softclip;
	src = Pan2.ar(src, pan);
	// src = (src*3).tanh * 0.33;
	OffsetOut.ar(out, src*amp);

},
metadata:(specs: (detune: ControlSpec(0,10,4), release: ControlSpec(0,2, 2), mix: ControlSpec(0,1), attack: ControlSpec(0,1,2)), oscReplies:["/l1_supersaw7V2/env", "/l1_supersaw7V2/pitchEnv"] )).add;

SynthDef.new(\l1fx_bpsEnvedV2,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673,    fq = 1, minF = 400, maxF = 12000.0, speedMax = 3, speedMin = -1, speed = 1, dropTime = 0.1, dropDecay = 0.2, volCurve = 10, duckT = 0.2, duck = 0, duckLen =0.2, attack = 0.003, shiftFreqs = 0;
	var input, fx, env, verb, quitAfter, freqs, volumes, sineF, moveFs, ducks, output;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	ducks = Env.new(1-[1,1,0,1], [duckT,duckLen*0.555,duckLen*0.444], [4,-4]).ar(0,1);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV2/duck", ducks, replyID);

	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV2/env", env, replyID);


	input = In.ar(in,2);
	//
	moveFs = Env.pairs([[0,1],[dropTime,1], [dropTime+dropDecay,0.2]],0).ar(0,1).lag(0,[0,0.1,0.02,0.5]);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV2/moveFs", moveFs[0], replyID);

	// freqs = LFNoise1.ar(9).range([0,1].resamp1(8).stutter(2).linexp(0,1,100,8000), [0,1].resamp1(8).stutter(2).linexp(0,1,300,12000));
	freqs = [0,1].resamp1(6).linexp(0,1,minF,maxF) * moveFs * shiftFreqs.midiratio;

	// SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/freqs", freqs, replyID);

	sineF = Env.perc(0,speed,1,0).ar(0,1).linlin(0,1,speedMin,speedMax);
	volumes = LFSaw.ar(sineF, [1,1]*[0,2pi].resamp1(6)).lag(0.05);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV2/rawVolumeLFO", volumes[0], replyID);
	volumes = volumes.lincurve(-1,1,0.01,1,volCurve);
	// volumes.scope;
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV2/volumes", volumes, replyID);

	fx = BPF.ar(input,freqs.clip(20,12000).stutter(2), fq.clip(0.1,1), fq.linlin(0.1,1, 3,0.5) * 1*(volumes.stutter(2)));
	// fx = input;
	fx = Mix.new(fx);

	output = ((dry*input) + fx)*env*amp * (1-(ducks*duck.clip(0,1)));
	output = output * Env.perc(0,attack,1,10).ar(0,1).linlin(0,1,1,0);

	Out.ar(out, output);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:[ "/l1fx_bpsEnvedV2/volumes", "/l1fx_bpsEnvedV2/rawVolumeLFO", "/l1fx_bpsEnvedV2/env", "/l1fx_bpsEnvedV2/duck", "/l1fx_bpsEnvedV2/moveFs"], oscRepliesWithSize: ('/l1fx_bpsEnvedV2/volumes': 6, '/l1fx_bpsEnvedV2/rawVolumeLFO':1, '/l1fx_bpsEnvedV2/env':1, '/l1fx_bpsEnvedV2/duck':1, '/l1fx_bpsEnvedV2/moveFs':1))
).add;


SynthDef.new(\l1fx_filterStab,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673, lowCutoff = 100, fEnvCurve = 0, fDecay = 0.7, attack = 0;
	var input, fx, env, verb, quitAfter, fenv, dipEnv, dipEnv2;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(attack*0.2, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	dipEnv = Env.perc(0.03,0.06,1,[-1,1]* 5).ar(0,1);
	dipEnv = DelayN.ar(dipEnv, 0.2,0.08);

	dipEnv2 = Env.perc(0.02,0.01,1,[-1,1]* 10).ar(0,1);
	dipEnv2 = DelayN.ar(dipEnv2, 0.2,0.02);

	fenv = Env.perc(attack,fDecay,1,-4).ar(0,1);

	input = In.ar(in,2);
	fx = MoogLadder.ar(input *dipEnv.lincurve(0,1,1,-0.04,0),fenv.lincurve(0,1,lowCutoff,20000,fEnvCurve) * dipEnv2.linlin(0,1,1,0.1),0.3 + dipEnv2.linlin(0,1,0,0.4));
	fx = (fx*2).tanh;

	Out.ar(out, ((dry*input) + (fx*amp))*env);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_pulseFitPerc,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, highFreq = 800, decay = 0.9, sharpness = 10,sharpnessDecay = 0.3, shiftBRF1 = -0.2, shiftBRF2 = 0, combDecay = 0.2, timeScale = 1;
	var src, env, quitAfter, snd, envMod2,envMod, sharpEnv, trig, volEnv;
	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);
	highFreq = freq;


	trig = 1;

	volEnv = Env.perc(0,1,decay,3).ar(0,1);
	envMod = Env.pairs([ [ 0.0, 0.47 ], [ 0.3, 1.0 ], [ 0.51, 0.0 ], [ 0.71, 0.62 ], [ 0.71, 0.9 ], [ 0.78, 0.28 ], [ 0.84, 0.34 ], [ 1.0, 0.74 ] ],[ -1.1, -0.8, 3.9, -3.5, 2.3, 0.7, -3.1, -0.3 ] * -2).ar(0,trig,0.4*timeScale);
	envMod2= Env.pairs([ [ 0.0, 0.23 ], [ 0.01, 1.0 ], [ 0.28, 0.16 ], [ 0.33, 0.07 ], [ 0.51, 0.49 ], [ 0.82, 0.66 ], [ 0.93, 0.13 ], [ 1.0, 0.0 ] ],[ -1.1, -0.8, 3.9, -3.5, 2.3, 0.7, -3.1, -0.3 ] * -2).ar(0,trig,1*timeScale);
	sharpEnv = Env.perc(0,sharpnessDecay,1,-5).ar(0,trig);
	snd = BBandStop.ar(Impulse.ar(envMod.linlin(0,1,40,20) * sharpEnv.linlin(0,1,1,sharpness), mul:0.1), envMod.lincurve(0,1,5000,1000,3)*shiftBRF1.linlin(-1,1,-12,12).midiratio,4).sanitize;
	snd = BBandStop.ar(snd, envMod2.lincurve(0,1,10000,500,-3)*shiftBRF2.linlin(-1,1,-12,12).midiratio,6).sanitize;
	snd = CombL.ar(snd, 0.2,( highFreq *[1.0, 2.76, 5.40, 8.90]* envMod.linlin(0,1,1,[0.9,1,1.1,1.4])).reciprocal,combDecay,mul:0.8).sum + snd;
	snd = LRLowCut.ar(snd,200,3,3);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	src = snd* amp*env*volEnv*4;
	src = src.softclip(-1,1);

	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1fx_cleanupBoost,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673;
	var input, fx, env, verb, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	// fx = CheapVerb.ar(input, 0.4,20);
	fx = LeakDC.ar(input);
	fx = HPF.ar(fx, 30);
	fx = Limiter.ar(fx, 1,0.0002);


	Out.ar(out, ((dry*input) + fx)*env*amp);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1fx_destroyLast,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673;
	var input, fx, env, verb, quitAfter;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	fx = CheapVerb.ar(input, 2,20);

	Out.ar(out, ((dry*input) + (fx*amp))*env);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_pressureReese2,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, timeScale = 1;
	var src, env, quitAfter;
	var osc, buf, dist, dist2, env1, env2, env3, fmOsc, hiMod, buf2, times, trig;

	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	buf = LocalBuf.newFrom(Env.pairs([[0,0], [0.2,-1], [0.5,0], [0.8,1], [1,0]],-20 * [-1,1]).asSignal(128).asWavetable);
	buf2 = LocalBuf.newFrom(Env.pairs([[0,0], [0.2,-1], [0.5,0], [0.8,1], [1,0]],4 * [-1,1]).asSignal(128).asWavetable);
	times = [ 0.498, 0.609, 0.6, 0.084, 0.312, 0.732, 2.604 ];
	// env = Env.pairs(8.collect{[rrand(0.0,2), rrand(-2,10)]},8.collect{rrand(-10,10)});
	trig = 1;
	env1 = Env.new([ 20, 14, 6, 0, 20, 20, 2, 1 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ]);
	env2 = Env.new([ 0.1, 0.1, 0.1, 1, 0.1, 0.0, 0, 0 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ].abs * -1).ar(0,trig, timeScale);
	env3 = Env.new([ 0, 0, 0, 1, 0, 0, 0, 0 ], times, [ 2, -6, -5, 9, 0, 10, 9, 0 ]).ar(0, trig,timeScale);



	env1 = env1.ar(0,trig,timeScale);
	fmOsc = SinOscFB.ar(freq*[64,48],0.4, 1).sum + WhiteNoise.ar(0.1);
	osc = SinOscFB.ar(freq *fmOsc.linlin(0,1,0,0).midiratio ,env3.lincurve(0,1,0.9,0,-2), mul:env1 , add: 0);
	dist = Shaper.ar(buf, osc);
	dist = SelectX.ar(0.9, [dist, Shaper.ar(buf2, osc)]);
	dist  = dist.ring1(fmOsc*0.12);


	hiMod = AllpassL.ar(dist, 0.2,[2,1,0.5,1.5]*2 * freq.reciprocal * dist.linlin(-1,1,-12,12).lag(0.02).midiratio,2 );
	hiMod =dist + Splay.ar(hiMod,0.4);

	hiMod = HPF.ar(hiMod, 5000) * 1.4;
	src = (hiMod + dist)*env2;

	src = src * amp * env*0.3;
	src = src.softclip;
	// src  = Limiter.ar(src );
	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;



SynthDef.new(\l1_pressureReese1,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, timeScale = 1;
	var src, env, quitAfter;
	var osc, buf, dist, dist2, env1, env2, env3, fmOsc, hiMod, buf2, times, trig;

	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	buf = LocalBuf.newFrom(Env.pairs([[0,0], [0.1,-1], [0.5,0], [0.6,1], [1,0]],10 * [-1,0.1]).asSignal(128).asWavetable);
	times = [ 0.16, 0.2, 1, 0.001, 0.01, 0.4, 2.604 ];
	trig = 1;
	env1 = Env.new([ 20, 14, 6, 0, 20, 20, 2, 1 ], times, [ 2, -6, -1, 9, 0, 10, 9, 0 ]* 1);
	env2 = Env.new([ 1, 0.2,0.4, 1, 0.2, 0.1, 0.05, 0 ], times, [ -2, -6, -4, 9, 0, 10, 9, 0 ].abs * -2).ar(0,trig,timeScale);



	env1 = env1.ar(0,trig,timeScale);
	osc = SinOscFB.ar(freq * [1,12],0.0 , mul:env1 * [1,0.3], add:Line.ar([-1,2],0,0.6)).sum;
	dist = Shaper.ar(buf, osc);

	// dist  = dist.ring1(fmOsc*0.12);


	hiMod = AllpassL.ar(dist, 0.2,[2,1,0.5,1.5]*2 * freq.reciprocal * dist.linlin(-1,1,-12,12).lag(0.02).midiratio,2 );
	hiMod =dist + Splay.ar(hiMod,0.4);

	hiMod = HPF.ar(hiMod, 5000) * 1;

	dist = LRHiCut.ar(dist, 500, 5,5) + LRLowCut.ar(dist, 800, 5,5);
	src = (hiMod + dist)*env2*0.2;

	src = src * amp * env;
	src = src.softclip;
	OffsetOut.ar(out, src!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;



SynthDef.new(\l1_bassFeed,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, feedback = 0.3, impulseDelayFreq = 100, resonLen = 2, excessAmp = 1, rotate = 0, highWidth = 0.25, clockSpeed  = 1, sineFB = 0, sineTune = 2, combDryWet = 1;

	var src, env, quitAfter, snd, fb, comb, pulse;
	env = Env.adsr(0.01, 0.3,1,0.05).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	SendReply.kr(Impulse.kr(60), "/l1_bassFeed/env", env, replyID);


	snd = Impulse.ar(0);
	snd = snd + DelayL.ar(snd, 0.2, impulseDelayFreq.reciprocal, -1);
	snd = snd + WhiteNoise.ar(0.02);


	fb = LocalIn.ar(2);
	fb = (fb* feedback) + snd;
	// fb = AllpassN.ar(fb, 0.2, LFPulse.ar(5).lag(0.1).range(10000,20),2);
	// fb = CombL.ar(fb, 0.2, 20000.reciprocal, resonLen);
	pulse = LFPulse.ar(0.25*clockSpeed,0,highWidth);
	SendReply.kr(Impulse.kr(60), "/l1_bassFeed/pulse", pulse, replyID);

	comb = CombL.ar(fb, 0.2, pulse.lag(0.01).range(20000,freq).reciprocal, resonLen);
	fb = SelectX.ar(combDryWet, [fb, comb]);

	// fb = MidEQ.ar(fb, freq*5, 5,-25);

	// ControlRate.reciprocal.poll;
	fb = fb.sanitize;
	// fb = fb
	fb = RotateL.ar(rotate,fb);
	fb = fb.excess(SinOscFB.ar(freq*[sineTune,3],sineFB ,mul:excessAmp));
	// fb = fb.softclip;
	fb = Compander.ar(fb, fb, 0.5,0.1);
	fb = Limiter.ar(fb,1,0.004);
	fb = LeakDC.ar(fb);
	// fb = LRLowCut.ar(fb, 40,1,1);
	LocalOut.ar(fb);

	fb = MidEQ.ar(fb[0], freq*2, 2,-9);

	snd = fb * amp * env;

	snd = snd.clip(-1,1);
	SendReply.kr(Impulse.kr(60), "/l1_bassFeed/ampFollow", Amplitude.ar(HPF.ar(snd, 300),0.016,0.02).excess(0.03), replyID);


	OffsetOut.ar(out, snd!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/l1_bassFeed/env", "/l1_bassFeed/pulse", "/l1_bassFeed/ampFollow"])
).add;


SynthDef.new(\l1_sineSuperReese,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, detuneOsc = 0.1, detuneEnvAmt = 0.4, detuneEnvTime = 0.3, detuneEnvShape = 5 , distoIn = 0.2, lfoTime = 2, subEnvAmnt = 36, subEnvTime =  0.3;
	var src, env, quitAfter;
	var snd, disto, distEnv, distEnv2, detuneEnv, sub, freqAmp;

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	freqAmp = AmpComp.ir(freq*3,87);

	detuneEnv = Env.perc(0,detuneEnvTime, detuneEnvAmt,detuneEnvShape).ar(0,1);


	distEnv = Env.new([0,0,1,0,0], [0,0.05,0.1+0.05,0]*2.5, 0,3,0).ar(0,1,lfoTime);
	distEnv2 = Env.new([0,0,1,0,0], [0,0.08,0.1-0.03 +0.05,0]*2.5, 0,3,0).ar(0,1, lfoTime);

	detuneOsc = detuneOsc + detuneEnv;

	snd = SinOsc.ar(freq*[1,3] * [detuneOsc.neg,detuneOsc].resamp1(12).midiratio, [2pi*0.0, 2pi*0.3].resamp1(12), mul:  freqAmp* 1/[10,15]).sum;

	sub = SinOsc.ar(freq*0.5 * Env.perc(0,subEnvTime,subEnvAmnt,-6).ar(0,1).midiratio, mul: 0.4);
	snd = snd  + sub;

	disto = snd.softclip;
	disto = (disto * distoIn.linlin(0,1,1,30)).tanh;
	disto = BRF.ar(disto, freq*3,2);
	disto = (disto * 4).tanh;
	disto = disto + HPF.ar(disto.excess(-12.dbamp),10000, 10);
	disto = HPF.ar(disto, freq*3, 4);
	disto = disto.tanh * 0.2;
	// snd = snd * distEnv.lincurve(0,1,1,0,4) + disto * distEnv.lincurve(0,1,0.1,3,4);
	snd = SelectX.ar( distEnv.lincurve(0,1,1,0.1,-10) , [snd, disto]);//snd * distEnv.lincurve(0,1,1,0,4) + disto * distEnv.lincurve(0,1,0.1,3,4);
	// snd = snd - sub;


	OffsetOut.ar(out, (snd*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_microSnare,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, noiseDelay = 0, shiftSpeed = -100, noiseDecayTime = 0.2;
	var src, env, quitAfter, snd, attack, noise;

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

		RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	noise = WhiteNoise.ar(DelayN.ar(Env.perc(0,noiseDecayTime,0.5,-4).ar(0,1),0.2,0.011*noiseDelay)) ;
	noise = noise + FreqShift.ar(noise, shiftSpeed,0,mul:0.6);
	// noise = noise.excess(SinOscFB.ar(40, 0.5).range(0.1,1));
	noise = noise.excess(0.2);
	attack = SinOscFB.ar(Env.perc(0,0.01,1,0).ar(0,1).lincurve(0,1,100,6000,9),0.2,mul:Env.perc(0,0.01,1,3).ar(0,1));
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);


	// snd = DelayN.ar(attack + noise,0.1,0.1);
	snd =attack + noise;
	// snd = DelayN.ar(snd,0.1,0.1);


	OffsetOut.ar(out, (snd*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef(\l1_superblip7, {
	arg freq = 1000, detune = 0.3, release = 0.2, mix = 0.4, amp = 1, out = 0, gate = 1, attack = 0, harmsMult = 1, pitchbend = 0, replyID = -1, pitchLen = 0.5, pitchAmt = 5, dip=1, dipEnd = 0.4, dipLen = 0.4, centerRatio = 1;
	var src, env, paned, pitchEnvs, srcTuned, dipEnv, voices, compAmp;

	voices = 4;

	freq = (pitchbend.midiratio) * freq;
	compAmp = AmpComp.ir(freq,100);
	env = EnvGen.ar(Env.adsr(attack, 0.1,0.8,release ),gate, doneAction:2);

	SendReply.kr(Impulse.kr(60), "/l1_supersaw7V2/env", env, replyID);

	pitchEnvs = Env.pairs([ [ 0.0, 0 ], [ 0.01, 1.0 ], [ 0.2, 0.1 ], [ 0.33, 0.02 ], [ 0.51, 0.1 ], [ 0.82, 0.13 ], [ 0.89, 0.05 ], [ 1.0, 0.0 ] ], [ 2.3, -3.4, -3.6, -1.1, -3.2, 1.7, -3.3, 3.0 ] * -1);
	pitchEnvs = pitchEnvs.ar(0,1,[1,1].resamp1(voices) * pitchLen);


	dipEnv = Env.perc(0.05,dipLen,1,-4).ar(0,1);
	dipEnv = DelayN.ar(dipEnv,dipEnd,[0.03,dipEnd].resamp1(voices));

	// src = SawDPW.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [-1,1].resamp1(7), mul:env );
	src = Blip.ar(freq * [-1*detune,detune].resamp1(voices).midiratio *(pitchEnvs*[1,-1].resamp1(voices) * pitchAmt).midiratio,[1,4,8,2]*harmsMult, mul:env );
	// src = Blip.ar(freq * [-1*detune,detune].resamp1(voices).midiratio *(pitchEnvs*[1,-1].resamp1(voices) * pitchAmt).midiratio,, [0+modPhase,2].resamp1(7).wrap(0,2), mul:env );
	src = src *dipEnv.linlin(0,1,1,1-dip);
	// dipEnv.scope;

	srcTuned = Blip.ar(freq *centerRatio*(pitchEnvs[0] * pitchAmt).midiratio, 1*harmsMult, mul:env * (1/(centerRatio.linlin(1,16,1,4,nil))).clip(0,1) );
	src = SelectX.ar(mix, [srcTuned*1/3, src.sum * 1/((voices+1)*0.6)]) * 1;
	src= src.softclip * compAmp;
	// src = (src*3).tanh * 0.33;
	OffsetOut.ar(out, src*amp!2);

},
metadata:(specs: (detune: ControlSpec(0,10,4), release: ControlSpec(0,2, 2), mix: ControlSpec(0,1), attack: ControlSpec(0,1,2)), oscReplies:["/l1_supersaw7V2/env"] )).add;


SynthDef.new(\l1fx_bpsEnvedV3,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673,    fq = 1, minF = 20, maxF = 20000, speedMax = 40, speedMin = 0.1, speed = 0.15, dropTime = 0.5, dropDecay = 0.2, volCurve = 10, duckT = 0.2, duck = 0, duckLen =0.2, attack = 0.003, delayTime = 0.08, lfoSpeed = 2;
	var input, fx, env, verb, quitAfter, freqs, volumes, sineF, moveFs, ducks, output, dropF;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	ducks = Env.new(1-[1,1,0,1], [duckT,duckLen*0.555,duckLen*0.444], [4,-4]).ar(0,1);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV3/duck", ducks, replyID);

	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV3/env", env, replyID);


	input = In.ar(in,2);
	//
	moveFs = Env.pairs([[0,1],[dropTime,1], [dropTime+dropDecay,0.2]],0).ar(0,1).lag(0,[0,0.1,0.02,0.5]);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV3/moveFs", moveFs[0], replyID);
	dropF = Env.perc(0,dropTime,1,0).ar(0,1);
	// dropF = SinOsc.ar([lfoSpeed,lfoSpeed*0.75]).range(0,1);

	// freqs = LFNoise1.ar(9).range([0,1].resamp1(8).stutter(2).linexp(0,1,100,8000), [0,1].resamp1(8).stutter(2).linexp(0,1,300,12000));
	freqs = [0,1].resamp1(6).linexp(0,1,minF,maxF) *dropF.linlin(0,1,0.25,1);

	// SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnved/freqs", freqs, replyID);

	sineF = Env.perc(0,speed,1,0).ar(0,1).linlin(0,1,speedMin,speedMax);
	volumes = LFPar.ar(sineF, [1,1]*[0,2pi].resamp1(6)).lag(0.05);
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV3/rawVolumeLFO", volumes[0], replyID);
	volumes = volumes.lincurve(-1,1,0.01,1,volCurve);
	// volumes.scope;
	SendReply.kr(Impulse.kr(60), "/l1fx_bpsEnvedV3/volumes", volumes, replyID);

	fx = BPF.ar(input,freqs.clip(20,12000).stutter(2), fq.clip(0.1,1), fq.linlin(0.1,1, 3,0.5) * 1*(volumes.stutter(2)));
	// fx = DelayN.ar(fx, 0.2,[0.02,0].resamp1(6));
	fx = Mix.new(fx);
	// fx = DelayN.ar(fx, 0.2,0.1) + fx;
	fx = fx+ CombL.ar(fx, 0.2,delayTime,0.5,0.5);
	// fx = fx+ CombL.ar(fx, 0.4,Env.perc(0,0.5,1,2).ar(0,1).linlin(0,1,0.1,0.3),1);

	output = ((dry*input) + fx)*env*amp * (1-(ducks*duck.clip(0,1)));
	output = output * Env.perc(0,attack,1,10).ar(0,1).linlin(0,1,1,0);

	Out.ar(out, output);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:[ "/l1fx_bpsEnvedV3/volumes", "/l1fx_bpsEnvedV3/rawVolumeLFO", "/l1fx_bpsEnvedV3/env", "/l1fx_bpsEnvedV3/duck", "/l1fx_bpsEnvedV3/moveFs"])
).add;


SynthDef.new(\l1_knarlReese,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, sinc = 100, lpfFactor = 16;
	var src, env, quitAfter;
	var snd, freqs, mod, filts, sincAmt, sincDist, env1, env2;

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	env1  = Env([ 1.0, 0.72, 0.17, 0.78, 0.0 ], [ 0.22, 0.06, 0.31, 0.41 ], [ 2.5, -6.7375886440277, 4.6099293231964, -4.0 ], nil, 0).ar(0,1);
	env2  = Env([ 0.0, 0.11, 0.85, 0.61, 0.91, 0.29, 0.83, 0.28, 0.0 ], [ 0.24, 0.14, 0.3, 0.14, 0.36, 0.54, 0.16, 0.12 ], [ 2.5, -6.7375886440277, 8.4397161006927, -0.78014194965363, -4.1843974590302, 6.5957450866699, -2.7659577131271, -2.5 ], nil, 0).ar(0,1);
	freqs = freq * ([1,2,4,3]);

	snd = VarSaw.ar(freqs,0,[0.1,0.7] + env1.linlin(0,1,0,[0.2,-0.6]),mul:{arg i; 0.5 * 1/(i+1)}!4 * (env1.linlin(0,1,1,0)));
	snd = snd + LFSaw.ar(freq, mul: env1*0.5);
	mod = SinOsc.ar([1,-2, -4]*0.5, mul: [1,0.4,0.6]).sum.range(0,1);
	filts = BPF.ar(snd, freqs*(([-12,7] * mod).midiratio),0.3,2).clip(-1,[0.1,0.2,0.3,0.4]);
	snd = (snd.sum.excess(mod.linlin(0,1,1,0.5))*0.5) + filts.sum;
	snd = LRLowCut.ar(snd,700,4,4) + (LRHiCut.ar(snd,300,4,4)*0.75);
	snd = (snd * env2.linlin(0,1,1,0.6)).tanh;
	snd = snd.excess(env2.linlin(0,1,0,0.05));

	sincAmt = env2.linlin(0,1,sinc,10);

	sincDist = 0.4 + snd;
	sincDist = ((sincDist*sincAmt).sin)/(sincDist*sincAmt);



	// sinc


	snd = ((snd - LRHiCut.ar(sincDist,freq * lpfFactor,1,1))*0.8).softclip;
	OffsetOut.ar(out, (snd*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_darkArtic,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, fm = 1, fmratio = 1, detuneFm = 1.01, mix = 0, attack = 0.01, sustainVal= 1;
	var src, env, quitAfter, modEnv, source, mod1,mod2, dist;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	modEnv = Env.linen(attack, sustainVal, 0.1).ar(0,1);
	// modEnv = EnvGen.ar(env, 1);

	mod1 = SinOsc.ar(freq*fmratio*(detuneFm.reciprocal), mul: fm * freq);
	mod2 = SinOsc.ar(freq*fmratio*detuneFm , mul: fm * freq);

	source = LFCub.ar( freq + mod1 + mod2);

	dist =  source.wrap(-0.1, 0.1) - DelayL.ar( source.wrap(-0.1342, 0.1244), 0.2, 0.02);
	// dist = MoogLadder.ar(dist*10, 200 + (WaveLoss.ar(source,1,2)*500) ,0.5).clip(-1,1);
	src = SelectX.ar(mix , [source, dist]);
	src = LeakDC.ar(src, mul:amp*modEnv);

	OffsetOut.ar(out, (src*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_formantBassRattle,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, phase = 1, phase2 = 0, formantFactor = 1, excessOsc = 1, attackPitchEnv = 1, pitchEnvTime = 1, attack = 0.01, wrap = 0.01, lfo1Speed = 1, lfo2Speed = 1, sustainLevel = 1, decay = 0.7;
	var src, env, quitAfter;
	var mod, mod1, mod2, pitchEnv;

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(attack, decay,sustainLevel ,0.05,amp,0).ar(0, gate);
	pitchEnv = Env([ 0.0, 1.0, 0.43, 0.18, 0.15, 0.01, 0.0, 0.0 ], [ 0.0, 0.009, 0.008, 0.025, 0.022, 0.036, 0.0 ], [ 0.0, -5.1773050427437, 2.0, -4.0, -7.0, -4.0, -4.0 ], nil, 0).ar(0,1, pitchEnvTime);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	mod = LFSaw.ar([1,2,3,4,6,2] * -0.25 * lfo1Speed,phase, add: SinOsc.ar(1 * lfo2Speed,([0,2].resamp1(6) + phase2)%2,0.5));
	mod1 = mod.sum.lincurve(-5,5,0,1,2);
	mod2 = (mod[[0,2,4]] - mod[[1,3,5]]).sum.lincurve(-2,2,0,1,2);

	// freq.poll;

	freq = freq * pitchEnv.linlin(0,1,1, 1+ attackPitchEnv);
	src = Formant.ar([freq, freq * 2], mod2.lag(0.02).linexp(0,1,freq,freq*5)*formantFactor, mod1.lag(0.02).linexp(0,1,[freq*2,2000],[2000,50]), mul:[1,0.25]).sum * mod1.linlin(0,1,0.5,1);

	// src = src + CombL.ar( BPF.ar((src + 0.1).fold(0.2),10000,2), 0.2, src.linlin(0,0.1,0.1,0.01), 0.5);
	// src = FreqShift.ar(src, -1200) + src;
	src = src +  BPF.ar((src + 0.1).wrap(wrap),11000,0.2, mul:2);
	src = (src*2).atan.excess(SinOsc.ar(freq,mul:excessOsc));
	src = LeakDC.ar(src);
	src = src.softclip;

	OffsetOut.ar(out, (src*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;



SynthDef(\l1_supersaw7_v2, {
	arg freq = 1000, detune = 0.3, release = 0.2, mix = 0.4, amp = 1, out = 0, gate = 1, attack = 0, modPhase = 0, pitchbend = 0, replyID = -1;
	var src, env, paned;
	freq = (pitchbend.midiratio) * freq;
	env = EnvGen.ar(Env.adsr(attack, 0.1,0.8,release ),gate, doneAction:2);

	SendReply.kr(Impulse.kr(60), "/l1_supersaw7/env", env, replyID);

	// src = SawDPW.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [-1,1].resamp1(7), mul:env );
	src = LFSaw.ar(freq * [-1*detune,detune].resamp1(7).midiratio, [0,1].resamp1(7).lincurve(0,1,0,2, 2), mul:env );

	src = SelectX.ar(mix, [src[3]*0.3, src.sum * 1/7]);
	OffsetOut.ar(out, src*amp!2);

},
metadata:(specs: (detune: ControlSpec(0,10,4), release: ControlSpec(0,2, 2), mix: ControlSpec(0,1), attack: ControlSpec(0,1,2)), oscReplies:["/l1_supersaw7/env"] )).add;

SynthDef.new(\l1fx_notchMove,{
	arg amp = 1, out = 0, in = 0, gate = 1, dry=0, replyID = -1,  seed = 5673, env1Time = 1, env2Time = 1, dip = 0, minFactor = 1, maxFactor = 1, env1Curve = 0, env2Curve  = 0, slopeAdd = 0, dryVolume = 0.1, dipLag = 0.07, bandSize = 0;
	var input, fx, env, verb, quitAfter, freqNotch, env1, env2, deri;
	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.0, 0.3,1,0.05).ar(0, gate);
	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	env1 = Env([ 1.0, 0.73, 0.38, 0.11, 0.19, 0.29, 0.23, 0.0 ], [ 0.09, 0.23, 0.15, 0.12, 0.08, 0.09, 0.24 ], [ -9.5, -7.0, 7.2, -0.2, -7.4, 2.4, 3.3 ] + env1Curve, nil, 0).ar(0,gate,env1Time);
	env2 = Env([ 0.0, 0.6, 1.0, 0.19, 0.72, 0.0, 0.5 ], [ 0.14, 0.13, 0.17, 0.15, 0.19, 0.22 ], [ -4.3, -5.1, 2.8, 2.7, 1.4, 0.1 ]+ env2Curve, nil, 0).ar(0,gate, env2Time);


	deri = Slope.ar((env1 + env2) * 0.2, add:1 + slopeAdd).wrap(-1,1).pow(0.5).lag(dipLag);
	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);
	input = In.ar(in,2);
	fx = input;
	freqNotch = env1.linexp(0,1,200, 1000);
	// fx = fx + AllpassL.ar(fx,0.2,  freqNotch.reciprocal, 0.02);
	fx = fx + AllpassL.ar(fx,0.2,  env2.lag(0.2, 0.2).linexp(0,1,200* minFactor, 4000* maxFactor).reciprocal, 0.001 + bandSize, mul:-0.5);
	fx = SVF.ar(fx, env1.linexp(0,1,100 * minFactor,2000 * maxFactor), res:0.01 + bandSize,lowpass:0, notch:1);
	fx = SVF.ar(fx, env2.linexp(0,1,300* minFactor,10000* maxFactor), res:0.01 + bandSize,lowpass:0, notch:1);
	fx = SVF.ar(fx, env1.linexp(0,1,20000* maxFactor,20* minFactor).lag(0.1), res:0.01 + bandSize,lowpass:0, notch:1);
	fx = SVF.ar(fx, env2.linexp(0,1,20000* maxFactor,20* minFactor).lag(0.1), res:0.01 + bandSize,lowpass:0, notch:1);
	fx = fx * dip.linlin(0,1,1,deri);
	fx  = fx + (input * dryVolume);
	// fx = CheapVerb.ar(input, 0.4,20);

	Out.ar(out, ((fx*amp))*env);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;

SynthDef.new(\l1_formantBassRattle,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, phase = 1, phase2 = 0, formantFactor = 1, excessOsc = 1, attackPitchEnv = 1, pitchEnvTime = 1, attack = 0.01, wrap = 0.01, lfo1Speed = 1, lfo2Speed = 1, sustainLevel = 1, decay = 0.7;
	var src, env, quitAfter;
	var mod, mod1, mod2, pitchEnv;

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(attack, decay,sustainLevel ,0.05,amp,0).ar(0, gate);
	pitchEnv = Env([ 0.0, 1.0, 0.43, 0.18, 0.15, 0.01, 0.0, 0.0 ], [ 0.0, 0.009, 0.008, 0.025, 0.022, 0.036, 0.0 ], [ 0.0, -5.1773050427437, 2.0, -4.0, -7.0, -4.0, -4.0 ], nil, 0).ar(0,1, pitchEnvTime);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);


	mod = LFSaw.ar([1,2,3,4,6,2] * -0.25 * lfo1Speed,phase, add: SinOsc.ar(1 * lfo2Speed,([0,2].resamp1(6) + phase2)%2,0.5));
	mod1 = mod.sum.lincurve(-5,5,0,1,2);
	mod2 = (mod[[0,2,4]] - mod[[1,3,5]]).sum.lincurve(-2,2,0,1,2);

	// freq.poll;

	freq = freq * pitchEnv.linlin(0,1,1, 1+ attackPitchEnv);
	src = Formant.ar([freq, freq * 2], mod2.lag(0.02).linexp(0,1,freq,freq*5)*formantFactor, mod1.lag(0.02).linexp(0,1,[freq*2,2000],[2000,50]), mul:[1,0.25]).sum * mod1.linlin(0,1,0.5,1);

	// src = src + CombL.ar( BPF.ar((src + 0.1).fold(0.2),10000,2), 0.2, src.linlin(0,0.1,0.1,0.01), 0.5);
	// src = FreqShift.ar(src, -1200) + src;
	src = src +  BPF.ar((src + 0.1).wrap(wrap),11000,0.2, mul:2);
	src = (src*2).atan.excess(SinOsc.ar(freq,mul:excessOsc));
	src = LeakDC.ar(src);
	src = src.softclip;

	OffsetOut.ar(out, (src*env)!2);
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;


SynthDef.new(\l1_notchyBass,{
	arg freq, amp = 1, out = 0, gate = 1, replyID = -1, seed = 1243, f1shift = 0, f2shift = 0, env1Scale = 0, fenvScale = 0, subVolume = 1, syncEnvMax = 2;
	var src, env, quitAfter;
	var env1, fenv, pulse, sub;

	RandID.ir(id: 0);
	RandSeed.ir(trig: 1, seed: seed);

	env = Env.adsr(0.01, 0.3,1,0.05,amp).ar(0, gate);

	quitAfter = Done.kr(env);
	quitAfter = DelayN.kr(quitAfter, 2/60, 2/60);// twoframe delay
	quitAfter = FreeSelf.kr(quitAfter);

	pulse = Impulse.ar(1);
	env1 = Env([ 0.0, 1.0, 0.53, 0.2, 0.23, 0.08, 0.0, 0.0 ], [ 0.0, 0.28, 0.22, 0.15, 0.19, 0.16, 0.0 ], [ 0.0, 6.0, -2.6241135597229, -4.0, -7.0, -4.0, -4.0 ], nil, 0).ar(0,pulse, (env1Scale*12).midiratio);
	// src = src * SinOscFB.ar(43 * 4,0.4);
	fenv = Env([ 1, 1.0, 0.64, 0.23, 0.62, 0.13, 0.0, 0.48, 0.25 ], [ 0.001, 0.15, 0.11, 0.15, 0.03, 0.13, 0.2, 0.23 ], [ -3.0, -0.8, 8.2, -6.6, 1.2, 4.4, -6.2 ], nil, 0).ar(0,pulse, (fenvScale*12).midiratio);
	// src  = RLPFD.ar(src*4, fenv.linexp(0,1,100,10000).lag(0.003) * (src *10),0.8,2,mul:2).softclip;
	src = SyncSaw.ar(freq * env1.linlin(0,1,1,1.04),freq * env1.linlin(0,1,1,syncEnvMax) ,mul: fenv.lincurve(0,1,0.1,1,-4))!2;

	src  = MoogFF.ar(src, fenv.linexp(0,1,200,10000) * (f1shift*12).midiratio,0.3,mul:1).softclip;
	src   = src   + Decimator.ar(src,bits:3, mul:-14.dbamp);
	src = SVF.ar(src, fenv.lag(0.4).lincurve(0,1,15000,100, -4) * (f2shift*12).midiratio, 0.01,0,0,0,1);

	sub = SinOsc.ar(fenv.linlin(0,1,50,20),mul:env1.lincurve(0,1,0,1,-3).lag(0.05) * subVolume);

	src = LRLowCut.ar(src, 120, 4);




	// SendReply.kr(Impulse.kr(60), "/instrument/param", env, replyID);

	src = src + (sub!2);

	OffsetOut.ar(out, (src*env));
},
metadata:(specs:(/*len:ControlSpec.new(0.1, 20), */), oscReplies:["/instrument/param"])
).add;



SynthDescLib.new(\lib1, s);
~synthsLib1 = [\l1_fxDown, \l1_ambiance, \l1_transient, \l1_noiseChord, \l1_hatWN, \l1_hatWN2, \l1_kick, \l1_bassSwell, \l1_supersaw7, \l1_fxDucker, \l1_hoover, \l1_12brass, \l1_brassReese, \l1_harmonicWash, \l1fx_mashedVerbPitch, \l1fx_lighterSpace, \l1_noiseChaos, \l1_samplePlayer, \l1fx_simpleVerb, \l1fx_reverseAmp, \l1_LaserSync, \l1_fullBass, \l1_deepbass, \l1fx_bpsEnved, \l1_simpleSines, \l1fx_pitchWave, \l1_digitoneV2, \l1_moreSyncSaw, \l1_reeseDouble, \l1_reeseLightHighs, \l1_clusterKick, \l1_decayKick, \l1_bendSub,\l1_rollerBass, \l1_trigToBus, \l1_riserBass, \l1_hiHit, \l1_gruntStab, \l1_laSnare, \l1_leKick, \l1_clumpSnare, \l1_supersaw7V2,\l1fx_bpsEnvedV2, \l1fx_filterStab, \l1_pulseFitPerc, \l1fx_cleanupBoost, \l1fx_destroyLast, \l1_pressureReese2, \l1_pressureReese1, \l1_bassFeed, \l1_microSnare, \l1_sineSuperReese,\l1_superblip7, \l1fx_bpsEnvedV3, \l1_knarlReese, \l1_darkArtic, \l1_formantBassRattle, \l1_supersaw7_v2, \l1fx_notchMove, \l1_formantBassRattle, \l1_notchyBass];
~synthsLib1.do{arg item; ("\\" ++ item); SynthDescLib.getLib(\lib1).add(SynthDescLib.global[item])};

// "\nSynthDescLib.getLib(\\lib1).browse\n".postln;
// "~postArgsPbind.value(\\l1_12brass)\n".postln;



"imported synthlib successfully".postln;
